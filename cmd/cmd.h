/*
*******************************************************************************
\file cmd.h
\brief Command-line interface to Bee2
\project bee2/cmd
\created 2022.06.09
\version 2022.07.15
\license This program is released under the GNU General Public License 
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

#ifndef __BEE2_CMD_H
#define __BEE2_CMD_H

#ifdef __cplusplus
extern "C" {
#endif

#include <bee2/core/blob.h>
#include <bee2/core/err.h>
#include <bee2/defs.h>

/*
*******************************************************************************
Блобы
*******************************************************************************
*/

/*! \brief Создание блоба */
#define cmdBlobCreate(blob, size) \
	(((blob) = blobCreate(size)) ? ERR_OK : ERR_OUTOFMEMORY)

/*! \brief Закрытие блоба */
#define cmdBlobClose blobClose

/*
*******************************************************************************
Регистрация команд
*******************************************************************************
*/

/*!	\brief Главная функция команды */
typedef int (*cmd_main_i)(
	int argc,				/*!< [in] число параметров командной строки */
	char* argv[]			/*!< [in] параметры командной строки */
);

/*!	\brief Регистрация команды

	Регистрируется команда с именем name, описанием descr и главной
	функцией fn.
	\expect Строки name и descr -- статические, указатели на них остаются
	корректными на протяжении всего времени выполнения. 
	\expect{ERR_BAD_FORMAT} 1 <= strLen(name) <= 8 && strLen(descr) <= 60.
	\return ERR_OK, если команда зарегистрирована, и код ошибки в противном
	случае.
*/
err_t cmdReg(
	const char* name, 		/*!< [in] имя команды */
	const char* descr,		/*!< [in] описание команды */
	cmd_main_i fn			/*!< [in] главная функция команды */
);

/*
*******************************************************************************
Файлы

\remark Пара параметров (count, files) функций cmdFilesValXXX() соответствует
паре (argc, argv) функции main(). Если заменить тип files на const char**,
то возможны предупредеждения компилятора при переходе от argv к files
(см. http://c-faq.com/ansi/constmismatch.html).
*******************************************************************************
*/

/*!	\brief Размер файла

	Определяется размер файла с именем file.
	\return Размер файла или SIZE_MAX в случае ошибки.
*/
size_t cmdFileSize(
	const char* file		/*!< [in] имя файла */
);

/*!	\brief Проверка отсутствия файлов

	Проверяется, что файлы списка [count]files отсутствуют и, таким образом,
	их можно создавать и записывать в них данные. Если некоторый файл все-таки
	присутствует, то предлагается его перезаписать. Разрешение на перезапись
	приравнивается к отсутствию файла.
	\return ERR_OK в случае успеха и код ошибки в противном случае. 
*/
err_t cmdFileValNotExist(
	int count,				/*!< [in] число файлов */
	char* files[]			/*!< [in] список имен файлов */
);

/*!	\brief Проверка наличия файлов

	Проверяется существование файлов списка [count]files.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileValExist(
	int count,				/*!< [in] число файлов */
	char* files[]			/*!< [in] список имен файлов */
);

/*!	\brief Чтение файла

	Содержимое файла file записывается в буфер buf (может быть NULL),
    а его длина записывается в buf_len (также может быть NULL)

    \expect имя файла file корректно

	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileRead(
    octet* buf,              /*!< [out] содержимое файла */
    size_t* buf_len,         /*!< [out] длина файлов */
    const char* file         /*!< [in]  имя файла */
);

/*!	\brief Чтение файла

	Из файла file читается buf_len октетов и записывается в буфер buf

    \expect имя файла file корректно
    \expect по адресу buf выделено buf_len октетов памяти

	\return число прочитанных октетов в случае успеха и SIZE_MAX в противном случае
*/
size_t cmdFileRead2(
    octet* buf,              /*!< [out] прочитанные октеты */
    size_t buf_len,          /*!< [in]  максимальное число октетов */
    const char* file         /*!< [in]  имя файла */
);

/*!	\brief Создание файла

	Создается файл file и заполняется содержимым буфера buf длины buf_len.

    \expect имя файла file корректно
    \expect по адресу buf выделено buf_len октетов памяти

	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileWrite(
    const octet* buf,         /*!< [in] буфер */
    size_t buf_len,           /*!< [in] длина буфера */
    const char* file          /*!< [in] имя файла */
);

/*
*******************************************************************************
Командная строка
*******************************************************************************
*/

/*!	\brief Создание списка аргументов

	По командной строке args строится список аргументов [argc]argv.
	\pre Указатели argc, argv и строка args корректны.
	\return Признак наличия файлов.
	\remark Аргументами считаются фрагменты args, разделенные пробелами.
	Фрагмент, окаймленный кавычками, считаются единым аргументом, даже если
	внутри него содержатся пробелы.
	\remark Детали:
	https://docs.microsoft.com/cpp/c-language/parsing-c-command-line-arguments
*/
err_t cmdArgCreate(
	int* argc,			/*!< [out] число аргументов */
	char*** argv,		/*!< [out] список аргументов */
	const char* args	/*!< [in] командная строка */
);

/*!	\brief Закрытие списка аргументов

	Закрывается список аргументов argv, созданный в функции cmdArgSplitStart().
	\pre cmdArgCreate() < cmdArgClose().
*/
void cmdArgClose(
	char** argv			/*!< [in] список аргументов */
);

/*
*******************************************************************************
Управление паролями

Пароль представляется собой стандартную C-строку (с завершающим нулем).

Пароль размещается в блобе, который создается внутри функций cmdPwdGen(),
cmdPwdRead(). Схема возврата [pwd_len?]pwd не используется, потому что
в некоторых случаях (например, при вводе пароля с консоли) важно, чтобы пароль
можно было возвратить за один вызов функции. За закрытие блоба отвечает
вызывающая программа.

Пароль задается в командной строке в стиле OpenSSL:
- обычно после аргумента "-pass" / "-passin" / "-passout" / ...;
- имеется несколько схем задания пароля;
- схема pass предлназначена для задания пароля прямо в командной строке:
  "-pass pass:password";
- схема share предлназначена для задания пароля с помощью методов
  разделения секрета в соответствии с правилами СТБ 34.101.78:
  "-pass share:\"share_descr\"";

В последнем случае параметры share_args, которые описывают настройку разделения
секрета, имеют следующий синтаксис:
\code
  [-tnn] [-lmmmm] -pass pass_arg share1 share2 ....
\endcode
Здесь:
- nn -- порог числа частичных секретов (2 <= n <= 16, 2 по умолчанию);
- mmm -- уровень стойкости (128, 192 или 256, 256 по умолчанию);
- pass_arg --- описание пароля защиты файлов с частичными секретами;
- share1, share2,... -- файлы с частичными секретами (их число должно быть не
  меньше порога и не больше 16).

\todo Поддержать опции "env:var", "file:pathname", "fd:number" и "stdin",
реализованные в OpenSSL
(https://www.openssl.org/docs/manmaster/man1/openssl-passphrase-options.html).

\todo Поддержать правила кодирования паролей, реализованные в OpenSSL
(https://www.openssl.org/docs/manmaster/man7/passphrase-encoding.html).
*******************************************************************************
*/

/*!	\brief Пароль */
typedef char* cmd_pwd_t;

/*!	\brief Создание пароля

	Создается блоб для хранения пароля максимальной длины size.
	\return Дескриптор блоба. Нулевой дескриптор возвращается
	при нехватке памяти.
	\remark При создании блоба все его октеты обнуляются.
*/
cmd_pwd_t cmdPwdCreate(
	size_t size			/*!< [in] максимальная длина */
);

/*!	\brief Корректный пароль?

	Проверяется корректность пароля pwd.
	\return Признак корректности.
	\remark Пароль корректен, если он хранится в корректном непустом блобе,
	который завершается нулевым октетом.
*/
bool_t cmdPwdIsValid(
	const cmd_pwd_t pwd		/*!< [in] корректный блоб */
);

/*!	\brief Закрытие пароля

	Выполняется очистка и освобождение блоба пароля pwd.
*/
void cmdPwdClose(
	cmd_pwd_t pwd		/*!< [in] пароль */
);

/*!	\brief Длина пароля */
#define cmdPwdLen strLen

/*!	\brief Построение пароля

	По инструкциям во фрагменте cmdline командной строки строится пароль pwd.
	\pre При использовании некоторых опций, в частности "share", должен быть
	проинициализирован штатный ГСЧ: rngIsValid() == TRUE.
	\return ERR_OK, если пароль успешно построен, и код ошибки 
	в противном случае.
	\remark За закрытие пароля отвечает вызывающая программа.
*/
err_t cmdPwdGen(
	cmd_pwd_t* pwd,			/*!< [out] пароль */
	const char* cmdline		/*!< [in] фрагмент командной строки */
);

/*!	\brief Определение пароля

	По инструкциям во фрагменте cmdline командной строки определяется 
	ранее построенный пароль pwd.
	\return ERR_OK, если пароль успешно определен, и код ошибки в противном
	случае.
	\remark За закрытие пароля отвечает вызывающая программа.
*/
err_t cmdPwdRead(
	cmd_pwd_t* pwd,			/*!< [out] пароль */
	const char* cmdline		/*!< [in] фрагмент командной строки */
);

/*
*******************************************************************************
Управление личными ключами СТБ 34.101.45 (bign)

Личные ключи хранятся в контейнерах, защищенных на паролях по схеме
СТБ 34.101.78 (bpki).

\expect Личный ключ связан со стандартными параметрами СТБ 34.101.45 того или
иного уровня стойкости: bign-curve256v1, bign-curve384v1 или bign-curve512v1.
*******************************************************************************
*/

/*!	\brief Запись личного ключа в контейнер

	Личный ключ [privkey_len]privkey записывается в защищенный файл-контейнер
	file. Защита устанавливается на пароле pwd.
	\return ERR_OK, если ключ успешно записан, и код ошибки	в противном случае.
*/
err_t cmdPrivkeyWrite(
	const octet privkey[],			/*!< [in] личный ключ */
	size_t privkey_len,				/*!< [in] длина личного ключа */
	const char* file,				/*!< [in] имя контейнера */
	const cmd_pwd_t pwd				/*!< [in] пароль защиты */
);

/*!	\brief Чтение личного ключа из контейнера

	Личный ключ [privkey_len?]privkey читается из защищенного файла-контейнера
	file. Защита снимается на пароле pwd.
	\pre Если адрес privkey_len ненулевой, то по этому адресу передается
	одно из следующих значений: 0, 32, 48, 64. Нулевое значение соответствует
	стандартной логике [privkey_len?]. Ненулевые значения соответствуют логике
	[?privkey_len], то есть задают требуемую длину ключа.
	\expect{ERR_BAD_FORMAT} Если privkey_len != 0 и *privkey_len != 0,
	то контейнер file содержит ключ из *privkey_len октетов.
	\return ERR_OK, если ключ успешно прочитан, и код ошибки в противном случае.
*/
err_t cmdPrivkeyRead(
	octet privkey[],				/*!< [out] личный ключ */
	size_t* privkey_len,			/*!< [out] длина личного ключа */
	const char* file,				/*!< [in] имя контейнера */
	const cmd_pwd_t pwd				/*!< [in] пароль защиты */
);

/*
*******************************************************************************
ГСЧ
*******************************************************************************
*/

/*!	\brief Запуск ГСЧ

	Запускается штатный ГСЧ. При установке флага verbose запуск сопровождается
	экранным выводом.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdRngStart(
	bool_t verbose			/*!< [in] печатать подробности */
);

/*!	\brief Тестирование ГСЧ

	Проверяется, что штатный ГСЧ удовлетворяет требованиям СТБ 34.101.27
	уровня 1: среди источников случайности, которые проходят тесты
	работоспособности (конкретнее, статистические тесты FIPS), имеется,
	один физический источник либо не менее двух разных альтернативных.
	\return ERR_OK, если тестирование прошло успешно, и ERR_BAD_ENTROPY
	в противном случае.
*/
err_t cmdRngTest();

/*
*******************************************************************************
ЭЦП
*******************************************************************************
*/

#define SIG_MAX_CERTS 16
#define SIG_MAX_CERT_SIZE 512
#define SIG_MAX_DER (SIG_MAX_CERTS * SIG_MAX_CERT_SIZE + 96 + 16)
#define CERTS_DELIM ','

typedef struct {
    size_t sig_len;	                    /*!< длина подписи в октетах */
    octet sig[96];	                    /*!< подпись */
    size_t certs_len[SIG_MAX_CERTS];    /*!< длины сертификатов */
} cmd_sig_t;

/*! \brief Чтение подписи из файла

    \return ERR_OK, если подпись прочитана успешно. Код ошибки в обратном случае.
 */
err_t cmdSigRead(
    size_t* der_len,      /*!< [out] длина der-кода */
    cmd_sig_t* sig,       /*!< [out] подпись. Может быть NULL, тогда подпись не возвращается */
    octet certs[],        /*!< [out] сертификаты. Может быть NULL, тогда сертификаты не возвращаются */
    const char* file      /*!< [in]  файл, содержащий подпись*/
);

/*! \brief Запись подписи в файл

    \remark Подпись читается с конца, поэтому может быть дописана в непустой,
    в частности исполняемый файл (при указании append = true)
    \return ERR_OK, если подпись записана успешно. Код ошибки в обратном случае.
 */
err_t cmdSigWrite(
    const cmd_sig_t* sig,       /*!< [in] подпись */
    octet certs[],              /*!< [in] сертификаты */
    const char* file,           /*!< [in] файл для записи */
    bool_t append               /*!< [in] дописать[TRUE]/перезаписать[FALSE] подпись */
);

/*!
    \brief Проверка подписи
    \return ERR_OK, если подпись корректна. Код ошибки в обратном случае.
 */
err_t cmdSigVerify(
    const octet* pubkey,              /*!< [in] открытый ключ (optional) */
    const octet* anchor_cert,         /*!< [in] доверенный сертификат (optional) */
    size_t anchor_cert_len,           /*!< [in] длина доверенного сертификата */
    const char* file,                 /*!< [in] проверяемый файл */
    const char* sig_file              /*!< [in] файл с подписью */
);

/*!
    \brief Выработка подписи
    \return ERR_OK, если подпись выработана успешно. Код ошибки в обратном случае.
 */
err_t cmdSigSign(
    cmd_sig_t * sig,                                 /*!< [out] подпись */
    const octet * privkey,                           /*!< [in]  личный ключ */
    size_t privkey_len,                              /*!< [in]  длина личного ключа */
    const octet* certs,                              /*!< [in]  сертификаты (optional) */
    const size_t certs_lens[SIG_MAX_CERTS],          /*!< [in]  длины сертификатов */
    const char* file                                 /*!< [in]  подписываемый файл */
);

/*!
    \brief Самопроверка подписи

    \remark Если в подпись включены сертификаты, оба параметра pubkey и anchor_cert
    могут быть null. В таком случае первый сертификат цепочки считается доверенным,
    а открытый ключ для проверки берется из последнего сертификата.
    \return ERR_OK, если подпись корректна, и код ошибки в обратном случае
 */
err_t cmdSigVerifySelf(
    const octet* pubkey,            /*!< [in] открытый ключ (optional) */
    const octet* anchor_cert,       /*!< [in] доверенный сертификат (optional) */
    size_t anchor_cert_len          /*!< [in] длина доверенного сертификата */
);

/*
*******************************************************************************
Аутентифицированное шифрование с присоединенными данными
*******************************************************************************
*/

/*! \brief Длина ключа */
#define CMD_AEAD_KEY_SIZE (size_t)32

/*! \brief Максимальная длина ключевого материала */
#define CMD_KEYLOAD_MAX_SIZE (size_t)1024

/*! \brief Заголовок зашифрованного файла */
typedef struct {
    octet keyload[CMD_KEYLOAD_MAX_SIZE];    /*!< ключевой материал */
    octet iv[16];                           /*!< синхропосылка */
    size_t itag;                            /*!< частоста имитовставок */
} cmd_aeadhead_t;

/*! \brief Максимальный размер DER-кода заголовка */
#define AEAD_HEAD_MAX_DER (size_t)(sizeof(cmd_aeadhead_t) + 128)

/*
*******************************************************************************
Описание типа ключевого материала
*******************************************************************************
*/

/*!	\brief Функция кодирования ключевого материала.

    \remark Der-код ключевого материала располагается в контейнере SEQUENCE
    с тегом этого материала. Требуется закодировать только содержание материала
    \return длина DER-кода или SIZE_MAX в случае ошибки
 */
typedef size_t (*keyload_encode_i)(
    octet* der,                         /*!< [out] DER-код */
    const octet *keload                 /*!< [in]  ключевой материал */
);

/*!	\brief Функция декодирования ключевого материала

    \return реальная длина DER-кода или SIZE_MAX в случае ошибки
 */
typedef size_t (*keyload_decode_i)(
    const octet* der,                  /*!< [in]   DER-код */
    octet *keload,                     /*!< [out]  ключевой материал */
    size_t count                       /*!< [out]  максимальная длина DER-кода */
);

/*!	\brief Функция защиты сеансового ключа

    \return ERR_OK в случае успеха и код ошибки в противном случае
*/
typedef err_t (*keyload_wrap_i)(
    octet *keload,                          /*!< [out] ключевой материал */
    const void *keyload_wrap,               /*!< [in] параметры для защиты */
    const octet key[CMD_AEAD_KEY_SIZE]      /*!< [in] сеансовый ключ */
);

/*!	\brief Функция снятия защиты сеансового ключа

    \return ERR_OK в случае успеха и код ошибки в противном случае
*/
typedef err_t (*keyload_unwrap_i)(
    const octet* keyload,                   /*!< [in] ключевой материал */
    const void* keyload_unwrap,             /*!< [in] параметры для снятия защиты */
    octet key[CMD_AEAD_KEY_SIZE]            /*!< [out] сеансовый ключ */
);

/*!	\brief Тип ключевого материала */
typedef struct {
    const u32 tag;                          /*!< тег материала */
    const keyload_encode_i encode;          /*!< функция кодирования */
    const keyload_decode_i decode;          /*!< функция декодирования */
    const keyload_wrap_i   wrap;            /*!< функция защиты сеансового ключа*/
    const keyload_unwrap_i unwrap;          /*!< функция снятия защиты сеансового ключа*/
} cmd_keyload_t;

// Ключевой материал PKE

/*! \brief Тип ключевого материала PKE

    Cеансовый ключ защищается на открытом ключе получателя с помощью
    алгоритма bign-keytransport.

    @see keyload_pke_t - cодержание ключевого материала
    @see keyload_pke_wrap_t - параметры для защиты сеансового ключа
    @see keyload_pke_unwrap_t - параметры для снятия защиты сеансового ключа
*/
const cmd_keyload_t* cmdAeadKeyloadPKE();

/*! \brief Тег ключевого материала PKE*/
#define CMD_KEYLOAD_TAG_PKE 0x61

/*! Содержание ключевого материала PKE */
typedef struct {
    octet ekey[64 + 16 + CMD_AEAD_KEY_SIZE];    /*!< защищенный ключ */
    octet cert[SIG_MAX_CERT_SIZE];              /*!< сертификат получателя */
    size_t cert_len;                            /*!< длина сертификата */
} keyload_pke_t;

/*! Параметры защиты сеансового ключа в режиме PKE */
typedef struct  {
    octet pubkey[128];             /*!< открытый ключ получателя */
    size_t pubkey_len;             /*!< длина открытого ключа (64/96/128) */
    octet cert[SIG_MAX_CERT_SIZE]; /*!< сертификат получателя */
    size_t cert_len;               /*!< длина сертификата */
} keyload_pke_wrap_t;

/*! Параметры снятия защиты сансового ключа в режиме PKE */
typedef struct {
    octet privkey[64];             /*!< личный ключ получателя */
    size_t privkey_len;            /*!< длина личного ключа (32/48/64) */
} keyload_pke_unwrap_t;

// Ключевой материал PWD

/** \brief Тип ключевого материала PWD

    Сеансовый ключ защищается алгоритмом beltKWP при помощи ключа, построенного
    по паролю алгоритмом beltPBKDF2.

    @see keyload_pwd_t - cодержание ключевого материала
    @see keyload_pwd_wrap_t - параметры для защиты сеансового ключа
    @see keyload_pwd_unwrap_t - параметры для снятия защиты сеансового ключа
 */
const cmd_keyload_t* cmdAeadKeyloadPWD();

/*! \brief Тег ключевого материала PWD*/
#define CMD_KEYLOAD_TAG_PWD 0x62

/*! Содержание ключевого материала PWD */
typedef struct {
    octet ekey[CMD_AEAD_KEY_SIZE + 16];         /*!< защищенный сеансовый ключ */
    octet salt[8];                              /*!< "соль" алгоритма beltPBKDF2 */
    size_t iter;                                /*!< число итераций алгоритма beltPBKDF2 */
} keyload_pwd_t;

/*! Параметры защиты сеансового ключа в режиме PWD */
typedef struct {
    octet pwd[256];                 /*!< пароль */
    size_t pwd_len;                 /*!< длина пароля */
    octet salt[8];                  /*!< "соль" алгоритма beltPBKDF2 */
    size_t iter;                    /*!< число итераций алгоритма beltPBKDF2 */
} keyload_pwd_wrap_t;

/*! Параметры снятия защиты сеансового ключа в режиме PWD */
typedef struct {
    octet pwd[256];                 /*!< пароль */
    size_t pwd_len;                 /*!< длина пароля */
} keyload_pwd_unwrap_t;

//Операции с заголовком и ключевым материалом

/*! \brief Защита сеансового ключа

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если защита проведена успешно, и
    код ошибки в обратном случае
 */
err_t cmdAeadWrapKey(
    octet *keload,                        /*!< [out] защищенный ключевой материал */
    const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
    const void *keyload_wrap,             /*!< [in]  параметры защиты */
    const octet key[CMD_AEAD_KEY_SIZE]    /*!< [in]  сеансовый ключ */
);

/*! \brief Снятие защиты сеансового ключа

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)
 
    \return ERR_OK, если защита снята успешно, и
    код ошибки в обратном случае
 */
err_t cmdAeadUnwrapKey(
    const octet* keyload,                 /*!< [in]  защищенный ключевой материал */
    const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
    const void* keyload_unwrap,           /*!< [in]  параметры снятия защиты */
    octet key[CMD_AEAD_KEY_SIZE]          /*!< [out] сеансовый ключ */
);

/*! \brief Чтение заголовка зашифрованного файла

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если заголовок прочитан успешно, и код
    ошибки в обратном случае
 */
err_t cmdAeadHeaderRead(
    size_t* der_len,                      /*!< [out] длина DER-кода (optional) */
    octet* der,                           /*!< [out] DER-код (optional) */
    cmd_aeadhead_t* header,               /*!< [out] заголовок */
    const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
    const char* file_name                 /*!< [in]  имя файла */
);

/*! \brief Запись заголовка в зашифрованный файл

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если заголовок записан успешно, и код
    ошибки в обратном случае
 */
err_t cmdAeadHeaderWrite(
    size_t* der_len,                      /*!< [out] длина DER-кода (optinal) */
    octet* der,                           /*!< [out] DER-код (optinal) */
    const cmd_aeadhead_t* header,         /*!< [in]  заголовок */
    const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
    const char* file_name                 /*!< [in] имя файла */
);

// Шифрование и дешифрование

/*! \brief Аутентифицированное шифрование данных по схеме CHE

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовый ключ защищается на пароле)

    \return ERR_OK, если файл зашифрован успешно, и код ошибки
    в обратном случае
 */
err_t cmdAeadEncrypt(
    const char* file,                       /*!< [in] имя шифруемого файла */
    const char* encrypted_file,             /*!< [in] имя выходного файла */
    size_t itag,                            /*!< [in] период промежуточных имитовставок (МБ) */
    const cmd_keyload_t* keyload_type,      /*!< [in] тип ключевого материала */
    const void* wrap_params,                /*!< [in] параметры для защиты сеансового ключа */
    const char* adata                       /*!< [in] файл с присоединенными данными */
);

/*! \brief Дешифрование аутентифицированного сообщения по схеме CHE

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовый ключ защищается на пароле)

    \return ERR_OK, если файл расшифрован успешно, и код ошибки
    в обратном случае
 */
err_t cmdAeadDecrypt(
    const char* file,                       /*!< [in] имя зашифрованного файла */
    const char* decrypted_file,             /*!< [in] имя выходного файла */
    const cmd_keyload_t* keyload_type,      /*!< [in] тип ключевого материала */
    const void* unwrap_params,              /*!< [in] параметры для снятия защиты сеансового ключа */
    const char* adata                       /*!< [in] файл с присоединенными данными */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_CMD_H */
