/*
*******************************************************************************
\file cmd.h
\brief Command-line interface to Bee2
\project bee2/cmd
\created 2022.06.09
\version 2022.07.15
\license This program is released under the GNU General Public License 
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

#ifndef __BEE2_CMD_H
#define __BEE2_CMD_H

#ifdef __cplusplus
extern "C" {
#endif

#include <bee2/core/blob.h>
#include <bee2/core/err.h>
#include <bee2/defs.h>

/*
*******************************************************************************
Блобы
*******************************************************************************
*/

/*! \brief Создание блоба */
#define cmdBlobCreate(blob, size) \
	(((blob) = blobCreate(size)) ? ERR_OK : ERR_OUTOFMEMORY)

/*! \brief Закрытие блоба */
#define cmdBlobClose blobClose

/*
*******************************************************************************
Регистрация команд
*******************************************************************************
*/

/*!	\brief Главная функция команды */
typedef int (*cmd_main_i)(
	int argc,				/*!< [in] число параметров командной строки */
	char* argv[]			/*!< [in] параметры командной строки */
);

/*!	\brief Регистрация команды

	Регистрируется команда с именем id, описанием descr и главной
	функцией fn.
	\expect Строки id и descr -- статические, указатели на них остаются
	корректными на протяжении всего времени выполнения. 
	\expect{ERR_BAD_FORMAT} 1 <= strLen(id) <= 8 && strLen(descr) <= 60.
	\return ERR_OK, если команда зарегистрирована, и код ошибки в противном
	случае.
*/
err_t cmdReg(
	const char* name, 		/*!< [in] имя команды */
	const char* descr,		/*!< [in] описание команды */
	cmd_main_i fn			/*!< [in] главная функция команды */
);

/*
*******************************************************************************
Файлы

\remark Пара параметров (count, files) функций cmdFilesValXXX() соответствует
паре (argc, argv) функции main(). Если заменить тип files на const char**,
то возможны предупредеждения компилятора при переходе от argv к files
(см. http://c-faq.com/ansi/constmismatch.html).
*******************************************************************************
*/

/*!	\brief Размер файла

	Определяется размер файла с именем file.
	\return Размер файла или SIZE_MAX в случае ошибки.
*/
size_t cmdFileSize(
	const char* file		/*!< [in] имя файла */
);

/*!	\brief Проверка отсутствия файлов

	Проверяется, что файлы списка [count]files отсутствуют и, таким образом,
	их можно создавать и записывать в них данные. Если некоторый файл все-таки
	присутствует, то предлагается его перезаписать. Разрешение на перезапись
	приравнивается к отсутствию файла.
	\return ERR_OK в случае успеха и код ошибки в противном случае. 
*/
err_t cmdFileValNotExist(
	int count,				/*!< [in] число файлов */
	char* files[]			/*!< [in] список имен файлов */
);

/*!	\brief Проверка наличия файлов

	Проверяется существование файлов списка [count]files.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileValExist(
	int count,				/*!< [in] число файлов */
	char* files[]			/*!< [in] список имен файлов */
);

/*!	\brief Чтение файла

	Содержимое файла file записывается в буфер buf (может быть NULL),
    а его длина записывается в buf_len (также может быть NULL)

    \expect имя файла file корректно

	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileRead(
    octet* buf,              /*!< [out] содержимое файла */
    size_t* buf_len,         /*!< [out] длина файлов */
    const char* file         /*!< [in]  имя файла */
);

/*!	\brief Чтение файла

	Из файла file читается buf_len октетов и записывается в буфер buf

    \expect имя файла file корректно
    \expect по адресу buf выделено buf_len октетов памяти

	\return число прочитанных октетов в случае успеха и SIZE_MAX в противном случае
*/
size_t cmdFileRead2(
    octet* buf,              /*!< [out] прочитанные октеты */
    size_t buf_len,          /*!< [in]  максимальное число октетов */
    const char* file         /*!< [in]  имя файла */
);

/*!	\brief Создание файла

	Создается файл file и заполняется содержимым буфера buf длины buf_len.

    \expect имя файла file корректно
    \expect по адресу buf выделено buf_len октетов памяти

	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileWrite(
    const octet* buf,         /*!< [in] буфер */
    size_t buf_len,           /*!< [in] длина буфера */
    const char* file          /*!< [in] имя файла */
);

/*
*******************************************************************************
Командная строка
*******************************************************************************
*/

/*!	\brief Создание списка аргументов

	По командной строке args строится список аргументов [argc]argv.
	\pre Указатели argc, argv и строка args корректны.
	\return Признак наличия файлов.
	\remark Аргументами считаются фрагменты args, разделенные пробелами.
	Фрагмент, окаймленный кавычками, считаются единым аргументом, даже если
	внутри него содержатся пробелы.
	\remark Детали:
	https://docs.microsoft.com/cpp/c-language/parsing-c-command-line-arguments
*/
err_t cmdArgCreate(
	int* argc,			/*!< [out] число аргументов */
	char*** argv,		/*!< [out] список аргументов */
	const char* args	/*!< [in] командная строка */
);

/*!	\brief Закрытие списка аргументов

	Закрывается список аргументов argv, созданный в функции cmdArgSplitStart().
	\pre cmdArgCreate() < cmdArgClose().
*/
void cmdArgClose(
	char** argv			/*!< [in] список аргументов */
);

/*
*******************************************************************************
Управление паролями

Пароль представляется собой стандартную C-строку (с завершающим нулем).

Пароль размещается в блобе, который создается внутри функций cmdPwdGen(),
cmdPwdRead(). Схема возврата [pwd_len?]pwd не используется, потому что
в некоторых случаях (например, при вводе пароля с консоли) важно, чтобы пароль
можно было возвратить за один вызов функции. За закрытие блоба отвечает
вызывающая программа.

Пароль задается в командной строке в стиле OpenSSL:
- обычно после аргумента "-pass" / "-passin" / "-passout" / ...;
- имеется несколько схем задания пароля;
- схема pass предлназначена для задания пароля прямо в командной строке:
  "-pass pass:password";
- схема share предлназначена для задания пароля с помощью методов
  разделения секрета в соответствии с правилами СТБ 34.101.78:
  "-pass share:\"share_descr\"";

В последнем случае параметры share_args, которые описывают настройку разделения
секрета, имеют следующий синтаксис:
\code
  [-tnn] [-lmmmm] -pass pass_arg share1 share2 ....
\endcode
Здесь:
- nn -- порог числа частичных секретов (2 <= n <= 16, 2 по умолчанию);
- mmm -- уровень стойкости (128, 192 или 256, 256 по умолчанию);
- pass_arg --- описание пароля защиты файлов с частичными секретами;
- share1, share2,... -- файлы с частичными секретами (их число должно быть не
  меньше порога и не больше 16).

\todo Поддержать опции "env:var", "file:pathname", "fd:number" и "stdin",
реализованные в OpenSSL
(https://www.openssl.org/docs/manmaster/man1/openssl-passphrase-options.html).

\todo Поддержать правила кодирования паролей, реализованные в OpenSSL
(https://www.openssl.org/docs/manmaster/man7/passphrase-encoding.html).
*******************************************************************************
*/

/*!	\brief Пароль */
typedef char* cmd_pwd_t;

/*!	\brief Создание пароля

	Создается блоб для хранения пароля максимальной длины size.
	\return Дескриптор блоба. Нулевой дескриптор возвращается
	при нехватке памяти.
	\remark При создании блоба все его октеты обнуляются.
*/
cmd_pwd_t cmdPwdCreate(
	size_t size			/*!< [in] максимальная длина */
);

/*!	\brief Корректный пароль?

	Проверяется корректность пароля pwd.
	\return Признак корректности.
	\remark Пароль корректен, если он хранится в корректном непустом блобе,
	который завершается нулевым октетом.
*/
bool_t cmdPwdIsValid(
	const cmd_pwd_t pwd		/*!< [in] корректный блоб */
);

/*!	\brief Закрытие пароля

	Выполняется очистка и освобождение блоба пароля pwd.
*/
void cmdPwdClose(
	cmd_pwd_t pwd		/*!< [in] пароль */
);

/*!	\brief Длина пароля */
#define cmdPwdLen strLen

/*!	\brief Построение пароля

	По инструкциям во фрагменте cmdline командной строки строится пароль pwd.
	\pre При использовании некоторых опций, в частности "share", должен быть
	проинициализирован штатный ГСЧ: rngIsValid() == TRUE.
	\return ERR_OK, если пароль успешно построен, и код ошибки 
	в противном случае.
	\remark За закрытие пароля отвечает вызывающая программа.
*/
err_t cmdPwdGen(
	cmd_pwd_t* pwd,			/*!< [out] пароль */
	const char* cmdline		/*!< [in] фрагмент командной строки */
);

/*!	\brief Определение пароля

	По инструкциям во фрагменте cmdline командной строки определяется 
	ранее построенный пароль pwd.
	\return ERR_OK, если пароль успешно определен, и код ошибки в противном
	случае.
	\remark За закрытие пароля отвечает вызывающая программа.
*/
err_t cmdPwdRead(
	cmd_pwd_t* pwd,			/*!< [out] пароль */
	const char* cmdline		/*!< [in] фрагмент командной строки */
);

/*
*******************************************************************************
Управление личными ключами СТБ 34.101.45 (bign)

Личные ключи хранятся в контейнерах, защищенных на паролях по схеме
СТБ 34.101.78 (bpki).

\expect Личный ключ связан со стандартными параметрами СТБ 34.101.45 того или
иного уровня стойкости: bign-curve256v1, bign-curve384v1 или bign-curve512v1.
*******************************************************************************
*/

/*!	\brief Запись личного ключа в контейнер

	Личный ключ [privkey_len]privkey записывается в защищенный файл-контейнер
	file. Защита устанавливается на пароле pwd.
	\return ERR_OK, если ключ успешно записан, и код ошибки	в противном случае.
*/
err_t cmdPrivkeyWrite(
	const octet privkey[],			/*!< [in] личный ключ */
	size_t privkey_len,				/*!< [in] длина личного ключа */
	const char* file,				/*!< [in] имя контейнера */
	const cmd_pwd_t pwd				/*!< [in] пароль защиты */
);

/*!	\brief Чтение личного ключа из контейнера

	Личный ключ [privkey_len?]privkey читается из защищенного файла-контейнера
	file. Защита снимается на пароле pwd.
	\pre Если адрес privkey_len ненулевой, то по этому адресу передается
	одно из следующих значений: 0, 32, 48, 64. Нулевое значение соответствует
	стандартной логике [privkey_len?]. Ненулевые значения соответствуют логике
	[?privkey_len], то есть задают требуемую длину ключа.
	\expect{ERR_BAD_FORMAT} Если privkey_len != 0 и *privkey_len != 0,
	то контейнер file содержит ключ из *privkey_len октетов.
	\return ERR_OK, если ключ успешно прочитан, и код ошибки в противном случае.
*/
err_t cmdPrivkeyRead(
	octet privkey[],				/*!< [out] личный ключ */
	size_t* privkey_len,			/*!< [out] длина личного ключа */
	const char* file,				/*!< [in] имя контейнера */
	const cmd_pwd_t pwd				/*!< [in] пароль защиты */
);

/*
*******************************************************************************
ГСЧ
*******************************************************************************
*/

/*!	\brief Запуск ГСЧ

	Запускается штатный ГСЧ. При установке флага verbose запуск сопровождается
	экранным выводом.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdRngStart(
	bool_t verbose			/*!< [in] печатать подробности */
);

/*!	\brief Тестирование ГСЧ

	Проверяется, что штатный ГСЧ удовлетворяет требованиям СТБ 34.101.27
	уровня 1: среди источников случайности, которые проходят тесты
	работоспособности (конкретнее, статистические тесты FIPS), имеется,
	один физический источник либо не менее двух разных альтернативных.
	\return ERR_OK, если тестирование прошло успешно, и ERR_BAD_ENTROPY
	в противном случае.
*/
err_t cmdRngTest();

/*
*******************************************************************************
ЭЦП
*******************************************************************************
*/

#define SIG_MAX_CERTS 16
#define SIG_MAX_CERT_SIZE 512
#define SIG_MAX_DER (SIG_MAX_CERTS * SIG_MAX_CERT_SIZE + 96 + 16)
#define CERTS_DELIM ','

typedef struct {
    size_t sig_len;	                    /*!< длина подписи в октетах */
    octet sig[96];	                    /*!< подпись */
    size_t certs_len[SIG_MAX_CERTS];    /*!< длины сертификатов */
} cmd_sig_t;

/*! \brief Чтение подписи из файла

    \return ERR_OK, если подпись прочитана успешно. Код ошибки в обратном случае.
 */
err_t cmdSigRead(
        size_t* der_len,      /*!< [out] длина der-кода */
        cmd_sig_t* sig,       /*!< [out] подпись. Может быть NULL, тогда подпись не возвращается */
        octet certs[],        /*!< [out] сертификаты. Может быть NULL, тогда сертификаты не возвращаются */
        const char* file      /*!< [in]  файл, содержащий подпись*/
);

/*! \brief Запись подписи в файл

    \return ERR_OK, если подпись записана успешно. Код ошибки в обратном случае.

    \remark Подпись читается с конца, поэтому может быть дописана в непустой,
    в частности исполняемый файл (при указании append = true)
 */
err_t cmdSigWrite(
        const cmd_sig_t* sig,       /*!< [in] подпись */
        octet certs[],              /*!< [in] сертификаты */
        const char* file,           /*!< [in] файл для записи */
        bool_t append               /*!< [in] дописать[TRUE]/перезаписать[FALSE] подпись */
);

/*!
    \brief Проверка подписи
    \return ERR_OK, если подпись корректна. Код ошибки в обратном случае.
 */
err_t cmdSigVerify(
        const octet* pubkey,              /*!< [in] открытый ключ (optional) */
        const octet* anchor_cert,         /*!< [in] доверенный сертификат (optional) */
        size_t anchor_cert_len,           /*!< [in] длина доверенного сертификата */
        const char* file,                 /*!< [in] проверяемый файл */
        const char* sig_file              /*!< [in] файл с подписью */
);

/*!
    \brief Выработка подписи
    \return ERR_OK, если подпись выработана успешно. Код ошибки в обратном случае.
 */
err_t cmdSigSign(
        cmd_sig_t * sig,                                 /*!< [out] подпись */
        const octet * privkey,                           /*!< [in]  личный ключ */
        size_t privkey_len,                              /*!< [in]  длина личного ключа */
        const octet* certs,                              /*!< [in]  сертификаты (optional) */
        const size_t certs_lens[SIG_MAX_CERTS],          /*!< [in]  длины сертификатов */
        const char* file                                 /*!< [in]  подписываемый файл */
);

/*!
    \brief Самопроверка подписи

    \remark Если в подпись включены сертефикаты, оба параметра <pubkey> и <anchor_cert>
    могут быть null. В таком случае первый сертефикат цепочки считается доверенным,
    а открытый ключ для проверки берется из последнего сертефиката.

    \return ERR_OK, если подпись корректра, код ошибки в обратном случае
 */
err_t cmdVerifySelf(
    const octet* pubkey,            /*!< [in] открытый ключ (optional) */
    const octet* anchor_cert,       /*!< [in] доверенный сертификат (optional) */
    size_t anchor_cert_len          /*!< [in] длина доверенного сертификата */
);


/*
*******************************************************************************
Шифрование с открытым ключом
*******************************************************************************
*/

/*! \brief Идентификатор ключевого материала */
typedef u8 cmd_keyload_id;

/*! \brief Длина ключа */
#define CMD_PKE_KEY_SIZE 32

/*! \brief Максимальная длина ключевого материала */
#define CMD_KEYLOAD_MAX_SIZE 1024

/*! \brief Заголовок зашифрованного файла */
typedef struct {
    octet keyload[CMD_KEYLOAD_MAX_SIZE];    /*!< ключевой материал */
    cmd_keyload_id keyload_id;              /*!< идентификатор ключевого материала */
    octet iv[16];                           /*!< синхропосылка */
    size_t itag;                            /*!< частоста имитовставок */
} cmd_pkehead_t;

/*
*******************************************************************************
Ключевой материал PKE
*******************************************************************************
*/

/**
 * \brief Идентификатор ключевого материала
 *
 * Cеансовый ключ защищается на открытом ключе получателя с помощью
 * алгоритма bign-keytransport.
 * */
#define CMD_KEYLOAD_ID_PKE (cmd_keyload_id)1

/*! Ключевой материал PKE */
typedef struct {
    octet key[64 + 16 + CMD_PKE_KEY_SIZE];      /*!< защищенный ключ */
    octet cert[SIG_MAX_CERT_SIZE];              /*!< сертификат получателя */
    size_t cert_len;                            /*!< длина сертификата */
} keyload_pke_t;

/*! Параметры сборки ключевого материала PKE */
typedef struct  {
    octet pubkey[128];             /*!< [in] открытый ключ получателя */
    size_t pubkey_len;             /*!< [in] длина ключа */
    octet cert[SIG_MAX_CERT_SIZE]; /*!< [in] сертификат получателя */
    size_t cert_len;               /*!< [in] длина сертификата */
} keyload_pke_wrap_t;

/*! Параметры разбора ключевого материала PKE */
typedef struct  {
    octet privkey[64];             /*!< [in]  личный ключ получателя */
    size_t privkey_len;            /*!< [in]  длина личного ключа */
    octet cert[SIG_MAX_CERT_SIZE]; /*!< [out] сертификат получателя */
    size_t cert_len;               /*!< [out] длина сертификата */
} keyload_pke_unwrap_t;

// \todo реализовать другие типы ключевых материалов

/*
*******************************************************************************
*/

/*! \brief Сборка ключевого материала

    \return ERR_OK, если ключевой материал собран успешно, и
    код ошибки в обратном случае
 */
err_t cmdPkeWrapKey(
    octet *keload,                        /*!< [out] ключевой материал */
    cmd_keyload_id keyload_id,            /*!< [in]  идентификатор ключевого материала */
    octet *keyload_wrap,                  /*!< [in/out]  параметры сборки */
    const octet key[CMD_PKE_KEY_SIZE]     /*!< [in]  сеансовый ключ */
);

/*! \brief Разбор ключевого материала

    \return ERR_OK, если ключевой материал разобран успешно, и
    код ошибки в обратном случае
 */
err_t cmdPkeUnwrapKey(
    const octet* keyload,                  /*!< [in]  ключевой материал */
    cmd_keyload_id keyload_id,             /*!< [in]  идентификатор ключевого материала */
    octet* keyload_unwrap,                 /*!< [in/out]  параметры разбора */
    octet key[CMD_PKE_KEY_SIZE]            /*!< [out] сеансовый ключ */
);

/*! \brief Чтение заголовка зашифрованного файла

    \return ERR_OK, если заголовок прочитан успешно, и код
    ошибки в обратном случае
 */
err_t cmdPkeHeaderRead(
    size_t* der_len,            /*!< [out] длина DER-кода */
    cmd_pkehead_t* pke,         /*!< [out] заголовок */
    const char* file_name       /*!< [in]  имя файла */
);

/*! \brief Запись заголовка в зашифрованный файл

    \return ERR_OK, если заголовок записан успешно, и код
    ошибки в обратном случае
 */
err_t cmdPkeHeaderWrite(
    size_t* der_len,            /*!< [out] длина DER-кода */
    const cmd_pkehead_t* pke,   /*!< [in]  заголовок */
    const char* file_name       /*!< [out] имя файла */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_CMD_H */
