/*
*******************************************************************************
\file cmd.h
\brief Command-line interface to Bee2
\project bee2/cmd
\created 2022.06.09
\version 2022.10.28
\license This program is released under the GNU General Public License 
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

#ifndef __BEE2_CMD_H
#define __BEE2_CMD_H

#ifdef __cplusplus
extern "C" {
#endif

#include <bee2/defs.h>
#include <bee2/core/blob.h>
#include <bee2/core/err.h>
#include <bee2/core/tm.h>
#include <bee2/crypto/btok.h>

/*
*******************************************************************************
Блобы
*******************************************************************************
*/

/*! \brief Создание блоба */
#define cmdBlobCreate(blob, size) \
	(((blob) = blobCreate(size)) ? ERR_OK : ERR_OUTOFMEMORY)

/*! \brief Закрытие блоба */
#define cmdBlobClose blobClose

/*
*******************************************************************************
Регистрация команд
*******************************************************************************
*/

/*!	\brief Главная функция команды */
typedef int (*cmd_main_i)(
	int argc,				/*!< [in] число параметров командной строки */
	char* argv[]			/*!< [in] параметры командной строки */
);

/*!	\brief Регистрация команды

	Регистрируется команда с именем name, описанием descr и главной
	функцией fn.
	\expect Строки name и descr -- статические, указатели на них остаются
	корректными на протяжении всего времени выполнения. 
	\expect{ERR_BAD_FORMAT} 1 <= strLen(name) <= 8 && strLen(descr) <= 60.
	\return ERR_OK, если команда зарегистрирована, и код ошибки в противном
	случае.
*/
err_t cmdReg(
	const char* name, 		/*!< [in] имя команды */
	const char* descr,		/*!< [in] описание команды */
	cmd_main_i fn			/*!< [in] главная функция команды */
);

/*
*******************************************************************************
Терминал
*******************************************************************************
*/

/*!	\brief Нажата клавиша?

	Опрашивается теримнал и проверяется, что очередь нажатых клавиш не пуста.
	\return Признак нажатия.
	\remark Очередь очищается в том числе через вызовы cmdTermGetch().
*/
bool_t cmdTermKbhit();

/*!	\brief Чтение символа

	Прочитывается символ, введенный в терминале.
	\return Прочитанный символ.
	\remark Прочитанный символ не экранируется.
*/
int cmdTermGetch();

/*
*******************************************************************************
ГСЧ

В функции cmdKbRead() реализован клавиатурный источник энтропии. Реализация
соответствует СТБ 34.101.27-2011 (Б.7):
- при нажатии клавиш фиксируются значения высокоточного таймера (регистр TSC);
- разность между значениями регистра сохраняется, если друг за другом нажаты
  две различные клавиши и интервал между нажатиями более 50 мс;
- всего сохраняется 128 разностей;
- собранные разности объединяются и хэшируются;
- хэш-значение (32 октета) возвращается в качестве энтропийных данных.

Дополнительно в cmdKbRead() проверяется, что интервал между нажатиями клавиш
не превышает 5 секунд. При отсутствии активности со стороны пользователя
сбор данных от источника будет прекращен.

В функции cmdRngStart() проверяются требования СТБ 34.101.27-2020 уровня 1:
наличие работоспособного физического источника энтропии или двух различных
работоспособных источников. Если недостает одного источника, то задействуется
клавиатурный.
*******************************************************************************
*/

/*!	\brief Данные от клавиатурного источника энтропии

	Прочитываются даные data с клавиатурного источника энтропии.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdRngKbRead(
	tm_ticks_t data[128]	/*!< [out] данные */
);

/*!	\brief Запуск ГСЧ

	Запускается штатный ГСЧ. При установке флага verbose запуск сопровождается
	экранным выводом.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdRngStart(
	bool_t verbose			/*!< [in] печатать подробности */
);

/*
*******************************************************************************
Файлы

\remark Пара параметров (count, files) функций cmdFilesValXXX() соответствует
паре (argc, argv) функции main(). Если заменить тип files на const char**,
то возможны предупредеждения компилятора при переходе от argv к files
(см. http://c-faq.com/ansi/constmismatch.html).
*******************************************************************************
*/

/*!	\brief Размер файла

	Определяется размер файла с именем file.
	\return Размер файла или SIZE_MAX в случае ошибки.
*/
size_t cmdFileSize(
	const char* file		/*!< [in] имя файла */
);

/*!	\brief Запись в файл

	Создается файл file и в него записывается буфер [count]buf.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileWrite(
	const char* file,	/*!< [in] файл */
	const octet buf[],	/*!< [in] буфер */
	size_t count		/*!< [in] длина буфера */
);

/*!	\brief Чтение всего файла

	Буфер [?count]buf прочитывается из файла file. При ненулевом buf
	дополнительно проверяется, что переданная длина в точности совпадает
	с размером файла.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileReadAll(
	octet buf[],		/*!< [in] буфер */
	size_t* count,		/*!< [in] длина буфера */
	const char* file	/*!< [in] файл */
);

/*!	\brief Чтение файла

	Из файла file читается buf_len октетов и записывается в буфер buf

	\expect имя файла file корректно
	\expect по адресу buf выделено buf_len октетов памяти

	\return число прочитанных октетов в случае успеха и SIZE_MAX в противном случае
*/
size_t cmdFileRead2(
	octet* buf,              /*!< [out] прочитанные октеты */
	size_t buf_len,          /*!< [in]  максимальное число октетов */
	const char* file         /*!< [in]  имя файла */
);

/*!	\brief Проверка отсутствия файлов

	Проверяется, что файлы списка [count]files отсутствуют и, таким образом,
	их можно создавать и записывать в них данные. Если некоторый файл все-таки
	присутствует, то предлагается его перезаписать. Разрешение на перезапись
	приравнивается к отсутствию файла.
	\return ERR_OK в случае успеха и код ошибки в противном случае. 
*/
err_t cmdFileValNotExist(
	int count,				/*!< [in] число файлов */
	char* files[]			/*!< [in] список имен файлов */
);

/*!	\brief Проверка наличия файлов

	Проверяется существование файлов списка [count]files.
	\return ERR_OK в случае успеха и код ошибки в противном случае.
*/
err_t cmdFileValExist(
	int count,				/*!< [in] число файлов */
	char* files[]			/*!< [in] список имен файлов */
);

/*!	\brief Проверка совпадения файлов

	Проверяется, что имена file1 и file2 соответствуют одному и тому же файлу.
	\return Признак успеха.
	\remark Корректность имен не проверяется.
*/
bool_t cmdFileAreSame(
	const char* file1,		/*!< [in] первый файл */
	const char* file2		/*!< [in] второй файл */
);

/*
*******************************************************************************
Командная строка
*******************************************************************************
*/

/*!	\brief Создание списка аргументов

	По командной строке args строится список аргументов [argc]argv.
	\pre Указатели argc, argv и строка args корректны.
	\return ERR_OK в случае успеха и код ошибки в противном случае. 
	\remark Аргументами считаются фрагменты args, разделенные пробелами.
	Фрагмент, окаймленный кавычками, считаются единым аргументом, даже если
	внутри него содержатся пробелы.
	\remark Детали:
	https://docs.microsoft.com/cpp/c-language/parsing-c-command-line-arguments
*/
err_t cmdArgCreate(
	int* argc,			/*!< [out] число аргументов */
	char*** argv,		/*!< [out] список аргументов */
	const char* args	/*!< [in] командная строка */
);

/*!	\brief Закрытие списка аргументов

	Закрывается список аргументов argv, созданный в функции cmdArgCreate().
	\pre cmdArgCreate() < cmdArgClose().
*/
void cmdArgClose(
	char** argv			/*!< [in] список аргументов */
);

/*
*******************************************************************************
Управление паролями

Пароль представляется собой стандартную C-строку (с завершающим нулем).

Пароль размещается в блобе, который создается внутри функций cmdPwdGen(),
cmdPwdRead(). Схема возврата [pwd_len?]pwd не используется, потому что
в некоторых случаях (например, при вводе пароля с консоли) важно, чтобы пароль
можно было возвратить за один вызов функции. За закрытие блоба отвечает
вызывающая программа.

Пароль задается в командной строке в стиле OpenSSL:
- обычно после аргумента "-pass" / "-passin" / "-passout" / ...;
- имеется несколько схем задания пароля;
- схема pass предлназначена для задания пароля прямо в командной строке:
  "-pass pass:password";
- схема share предлназначена для задания пароля с помощью методов
  разделения секрета в соответствии с правилами СТБ 34.101.78:
  "-pass share:\"share_descr\"";

В последнем случае параметры share_args, которые описывают настройку разделения
секрета, имеют следующий синтаксис:
\code
  [-tnn] [-lmmmm] -pass pass_arg share1 share2 ....
\endcode
Здесь:
- nn -- порог числа частичных секретов (2 <= n <= 16, 2 по умолчанию);
- mmm -- уровень стойкости (128, 192 или 256, 256 по умолчанию);
- pass_arg --- описание пароля защиты файлов с частичными секретами;
- share1, share2,... -- файлы с частичными секретами (их число должно быть не
  меньше порога и не больше 16).

\todo Поддержать опции "env:var", "file:pathname", "fd:number" и "stdin",
реализованные в OpenSSL
(https://www.openssl.org/docs/manmaster/man1/openssl-passphrase-options.html).

\todo Поддержать правила кодирования паролей, реализованные в OpenSSL
(https://www.openssl.org/docs/manmaster/man7/passphrase-encoding.html).
*******************************************************************************
*/

/*!	\brief Пароль */
typedef char* cmd_pwd_t;

/*!	\brief Создание пароля

	Создается блоб для хранения пароля максимальной длины size.
	\return Дескриптор блоба. Нулевой дескриптор возвращается
	при нехватке памяти.
	\remark При создании блоба все его октеты обнуляются.
*/
cmd_pwd_t cmdPwdCreate(
	size_t size			/*!< [in] максимальная длина */
);

/*!	\brief Корректный пароль?

	Проверяется корректность пароля pwd.
	\return Признак корректности.
	\remark Пароль корректен, если он хранится в корректном непустом блобе,
	который завершается нулевым октетом.
*/
bool_t cmdPwdIsValid(
	const cmd_pwd_t pwd		/*!< [in] корректный блоб */
);

/*!	\brief Закрытие пароля

	Выполняется очистка и освобождение блоба пароля pwd.
*/
void cmdPwdClose(
	cmd_pwd_t pwd		/*!< [in] пароль */
);

/*!	\brief Длина пароля */
#define cmdPwdLen strLen

/*!	\brief Построение пароля

	По инструкциям во фрагменте cmdline командной строки строится пароль pwd.
	\pre При использовании некоторых опций, в частности "share", должен быть
	проинициализирован штатный ГСЧ: rngIsValid() == TRUE.
	\return ERR_OK, если пароль успешно построен, и код ошибки 
	в противном случае.
	\remark За закрытие пароля отвечает вызывающая программа.
*/
err_t cmdPwdGen(
	cmd_pwd_t* pwd,			/*!< [out] пароль */
	const char* cmdline		/*!< [in] фрагмент командной строки */
);

/*!	\brief Определение пароля

	По инструкциям во фрагменте cmdline командной строки определяется 
	ранее построенный пароль pwd.
	\return ERR_OK, если пароль успешно определен, и код ошибки в противном
	случае.
	\remark За закрытие пароля отвечает вызывающая программа.
*/
err_t cmdPwdRead(
	cmd_pwd_t* pwd,			/*!< [out] пароль */
	const char* cmdline		/*!< [in] фрагмент командной строки */
);

/*
*******************************************************************************
Управление личными ключами СТБ 34.101.45 (bign)

Личные ключи хранятся в контейнерах, защищенных на паролях по схеме
СТБ 34.101.78 (bpki).

\expect Личный ключ связан со стандартными параметрами СТБ 34.101.45 того или
иного уровня стойкости: bign-curve256v1, bign-curve384v1 или bign-curve512v1.
*******************************************************************************
*/

/*!	\brief Запись личного ключа в контейнер

	Личный ключ [privkey_len]privkey записывается в защищенный файл-контейнер
	file. Защита устанавливается на пароле pwd.
	\return ERR_OK, если ключ успешно записан, и код ошибки	в противном случае.
*/
err_t cmdPrivkeyWrite(
	const octet privkey[],			/*!< [in] личный ключ */
	size_t privkey_len,				/*!< [in] длина личного ключа */
	const char* file,				/*!< [in] имя контейнера */
	const cmd_pwd_t pwd				/*!< [in] пароль защиты */
);

/*!	\brief Чтение личного ключа из контейнера

	Личный ключ [privkey_len?]privkey читается из защищенного файла-контейнера
	file. Защита снимается на пароле pwd.
	\pre Если адрес privkey_len ненулевой, то по этому адресу передается
	одно из следующих значений: 0, 32, 48, 64. Нулевое значение соответствует
	стандартной логике [privkey_len?]. Ненулевые значения соответствуют логике
	[?privkey_len], то есть задают требуемую длину ключа.
	\expect{ERR_BAD_FORMAT} Если privkey_len != 0 и *privkey_len != 0,
	то контейнер file содержит ключ из *privkey_len октетов.
	\return ERR_OK, если ключ успешно прочитан, и код ошибки в противном случае.
*/
err_t cmdPrivkeyRead(
	octet privkey[],				/*!< [out] личный ключ */
	size_t* privkey_len,			/*!< [out] длина личного ключа */
	const char* file,				/*!< [in] имя контейнера */
	const cmd_pwd_t pwd				/*!< [in] пароль защиты */
);

/*
*******************************************************************************
CV-сертификаты
*******************************************************************************
*/

/*!	\brief Печать CV-сертификата

	Печатается содержимое CV-сертификата cvc.
	\return ERR_OK, если печать успешно выполнена, и код ошибки
	в противном случае. 
*/
err_t cmdCVCPrint(btok_cvc_t* cvc);

/*
*******************************************************************************
ЭЦП

ЭЦП может сопровождаться цепочкой CV-сертификатов. Первым в цепочке идет
сертификат подписанта. Каждый следующий сертификат -- это сертификат
удостоверяющего центра, выпустившего предыдущий сертификат.

Цепочка сертификатов подписывается вместе с содержимым целевого файла.
При этом смена сертификата подписанта в цепочке сделает подпись
недействительной, даже если открытый ключ будет повторен в двух сертификатах
(см. описание угроз в RFC5035 и описание атрибута SigningCertificateV2
в этом же документе).

Формат ЭЦП:
\code
Signature ::= SEQUENCE
{
   certs SEQUENCE OF CVCertificate,
   sig OCTET STRING(SIZE(48|72|96))
}
\endcode

Для управления форматом предусмотрена структура cmd_sig_t. В поле certs
этой структуры размещается цепочка сертификатов. Сертификаты цепочки
записываются последовательно друг за другом без разделителей. Сертификаты
закодированы по правилам АСН.1, их длины однозначно определяются в ходе
декодирования.

Подпись также кодируется по правилам АСН.1. DER-код (строка октетов)
переворачивается. За счет переворота DER-код однозначно декодируется даже
будучи записанным в конец файла произвольного размера. В частности,
подпись может быть присоединена к подписывемому файлу. В этом случае при
проверке подписи она исключается из контролируемого содержимого файла.
*******************************************************************************
*/

typedef struct {
	octet sig[96];			/*!< подпись */
	size_t sig_len;	        /*!< длина подписи в октетах */
	octet certs[1460];		/*!< цепочка сертификатов */
	size_t certs_len;		/*!< cуммарная длина сертификатов */
} cmd_sig_t;

/*!	\brief Подпись файла

	Содержимое файла file подписывается на личном ключе [privkey_len]privkey.
	Подпись сохраняется в файле sig_file вместе с сертификатами цепочки certs.
	Цепочка certs может быть пустой. В качестве файла подписи можно указать
	подписываемый файл, и тогда подпись записывается в его конец.
	\expect{ERR_BAD_KEYPAIR} Если цепочка certs непуста, то ее первый
	сертификат соответствует privkey.
	\expect{ERR_BAD_CERT} Если цепочка certs непуста, то каждый ее сертификат,
	начиная со второго, -- это сертификат удостоверяющего центра, выпустившего
	предыдущий сертификат.
	\return ERR_OK, если файл успешно подписан, и код ошибки в противном
	случае.
	\remark В списке certs указываются имена файлов сертификатов. Имена
	разделяются пробелами. Имена могут окаймляться кавычками.
	\remark Файлы file и sig_file могут совпадать, и тогда подпись
	присоединяется к подписываемому файлу.
*/
err_t cmdSigSign(
	const char* sig_file,		/*!< [in] файл подписи */
	const char* file,			/*!< [in] подписываемый файл */
	const char* certs,			/*!< [in] цепочка сертификатов */
	const octet privkey[],		/*!< [in] личный ключ */
	size_t privkey_len			/*!< [in] длина личного ключа */
);

/*!	\brief Проверка подписи файла на открытом ключе

	Подпись содержимого файла file, размещенная в sig_file, проверяется
	на открытом ключе [pubkey_len]pubkey. В качестве файла подписи может
	указывать подписываемый файл, и тогда подпись прочитывается из его конца
	и исключается из содержимого файла при проверке.
	\expect{ERR_BAD_KEYPAIR} Если подпись сопровождается цепочкой сертификатов,
	то ее первый сертификат соответствует pubkey.
	\expect{ERR_BAD_CERT} Если подпись сопровождается цепочкой сертификат,
	то каждый ее сертификат, начиная со второго, -- это сертификат
	удостоверяющего центра, выпустившего предыдущий сертификат.
	\expect{ERR_BAD_FORMAT} Если подпись размещается в отдельном файле, то этот
	файл содержит исключительно подпись.
	\return ERR_OK, если подпись корректна, и код ошибки в противном случае.
*/
err_t cmdSigVerify(
	const char* file,			/*!< [in] подписанный файл */
	const char* sig_file,		/*!< [in] файл подписи */
	const octet pubkey[],		/*!< [in] открытый ключ */
	size_t pubkey_len			/*!< [in] длина открытого ключа */
);

/*!	\brief Проверка подписи файла на доверенном сертификате

	Подпись содержимого файла file, размещенная в sig_file, проверяется
	на доверенном сертификате [anchor_len]anchor. Проверка будет завершена
	успешно, если:
	- подпись сопровождается цепочкой сертификатов;
	- цепочка корректна: каждый ее сертификат, начиная со второго, -- это
	  сертификат удостоверяющего центра, выпустившего предыдущий сертификат;
	- подпись признается корректной на первом сертификате цепочки;
	- один из сертификатов цепочки совпадает с [anchor_len]anchor.
	В качестве файла подписи может указывать подписываемый файл, и тогда подпись
	прочитывается из его конца и исключается из содержимого файла при проверке.
	\expect{ERR_BAD_FORMAT} Если подпись размещается в отдельном файле, то этот
	файл содержит исключительно подпись.
	\return ERR_OK, если подпись корректна, и код ошибки в противном случае.
*/
err_t cmdSigVerify2(
	const char* file,			/*!< [in] подписанный файл */
	const char* sig_file,		/*!< [in] файл подписи */
	const octet anchor[],		/*!< [in] доверенный сертификат */
	size_t anchor_len			/*!< [in] длина anchor */
);

/*!	\brief Самопроверка подписи на открытом ключе

	Подпись исполнимого файла, в котором вызывается данная функция,
	прочитывается из конца этого же файла и проверяется на открытом ключе
	[pubkey_len]pubkey через обращение к cmdSigVerify(pubkey, pubkey_len).
	\return ERR_OK, если подпись корректна, и код ошибки в противном случае.
*/
err_t cmdSigSelfVerify(
	const octet pubkey[],		/*!< [in] открытый ключ */
	size_t pubkey_len			/*!< [in] длина открытого ключа */
);

/*!	\brief Самопроверка подписи на доверенном сертификате

	Подпись исполнимого файла, в котором вызывается данная функция,
	прочитывается из конца этого же файла и проверяется на доверенном
	сертификате [anchor_len]anchor через обращение к
	cmdSigVerify2(anchor, anchor_len).
	\return ERR_OK, если подпись корректна, и код ошибки в противном случае.
*/
err_t cmdSigSelfVerify2(
	const octet anchor[],		/*!< [in] доверенный сертификат */
	size_t anchor_len			/*!< [in] длина anchor */
);

/*!	\brief Печать подписи

	Печатается подпись, размещенная в конце файла sig_file. Вместе с подписью
	печатаются сопровождающие ее CV-сертификаты.
	\return ERR_OK, если печать успешно выполнена, и код ошибки в противном
	случае.
*/
err_t cmdSigPrint(
	const char* sig_file		/*!< [in] файл подписи */
);

/*
*******************************************************************************
Аутентифицированное шифрование с присоединенными данными
*******************************************************************************
*/

/*! \brief Длина ключа */
#define CMD_AEAD_KEY_SIZE (size_t)32

/*! \brief Максимальная длина ключевого материала */
#define CMD_KEYLOAD_MAX_SIZE (size_t)1024

/*! \brief Заголовок зашифрованного файла */
typedef struct {
    octet keyload[CMD_KEYLOAD_MAX_SIZE];    /*!< ключевой материал */
    octet iv[16];                           /*!< синхропосылка */
    size_t itag;                            /*!< частоста имитовставок */
} cmd_aeadhead_t;

/*! \brief Максимальный размер DER-кода заголовка */
#define AEAD_HEAD_MAX_DER (size_t)(sizeof(cmd_aeadhead_t) + 128)

/*
*******************************************************************************
Описание типа ключевого материала
*******************************************************************************
*/

/*!	\brief Функция кодирования ключевого материала.

    \remark Der-код ключевого материала располагается в контейнере SEQUENCE
    с тегом этого материала. Требуется закодировать только содержание материала
    \return длина DER-кода или SIZE_MAX в случае ошибки
 */
typedef size_t (*keyload_encode_i)(
        octet* der,                         /*!< [out] DER-код */
        const octet *keload                 /*!< [in]  ключевой материал */
);

/*!	\brief Функция декодирования ключевого материала

    \return реальная длина DER-кода или SIZE_MAX в случае ошибки
 */
typedef size_t (*keyload_decode_i)(
        const octet* der,                  /*!< [in]   DER-код */
        octet *keload,                     /*!< [out]  ключевой материал */
        size_t count                       /*!< [out]  максимальная длина DER-кода */
);

/*!	\brief Функция защиты сеансового ключа

    \return ERR_OK в случае успеха и код ошибки в противном случае
*/
typedef err_t (*keyload_wrap_i)(
        octet *keload,                          /*!< [out] ключевой материал */
        const void *keyload_wrap,               /*!< [in] параметры для защиты */
        const octet key[CMD_AEAD_KEY_SIZE]      /*!< [in] сеансовый ключ */
);

/*!	\brief Функция снятия защиты сеансового ключа

    \return ERR_OK в случае успеха и код ошибки в противном случае
*/
typedef err_t (*keyload_unwrap_i)(
        const octet* keyload,                   /*!< [in] ключевой материал */
        const void* keyload_unwrap,             /*!< [in] параметры для снятия защиты */
        octet key[CMD_AEAD_KEY_SIZE]            /*!< [out] сеансовый ключ */
);

/*!	\brief Тип ключевого материала */
typedef struct {
    const u32 tag;                          /*!< тег материала */
    const keyload_encode_i encode;          /*!< функция кодирования */
    const keyload_decode_i decode;          /*!< функция декодирования */
    const keyload_wrap_i   wrap;            /*!< функция защиты сеансового ключа*/
    const keyload_unwrap_i unwrap;          /*!< функция снятия защиты сеансового ключа*/
} cmd_keyload_t;

// Ключевой материал PKE

/*! \brief Тип ключевого материала PKE

    Cеансовый ключ защищается на открытом ключе получателя с помощью
    алгоритма bign-keytransport.

    @see keyload_pke_t - cодержание ключевого материала
    @see keyload_pke_wrap_t - параметры для защиты сеансового ключа
    @see keyload_pke_unwrap_t - параметры для снятия защиты сеансового ключа
*/
const cmd_keyload_t* cmdAeadKeyloadPKE();

/*! \brief Тег ключевого материала PKE*/
#define CMD_KEYLOAD_TAG_PKE 0x61

/*! Содержание ключевого материала PKE */
typedef struct {
    octet ekey[64 + 16 + CMD_AEAD_KEY_SIZE];    /*!< защищенный ключ */
    octet cert[512];                            /*!< сертификат получателя */
    size_t cert_len;                            /*!< длина сертификата */
} keyload_pke_t;

/*! Параметры защиты сеансового ключа в режиме PKE */
typedef struct  {
    octet pubkey[128];             /*!< открытый ключ получателя */
    size_t pubkey_len;             /*!< длина открытого ключа (64/96/128) */
    octet cert[512];               /*!< сертификат получателя */
    size_t cert_len;               /*!< длина сертификата */
} keyload_pke_wrap_t;

/*! Параметры снятия защиты сансового ключа в режиме PKE */
typedef struct {
    octet privkey[64];             /*!< личный ключ получателя */
    size_t privkey_len;            /*!< длина личного ключа (32/48/64) */
} keyload_pke_unwrap_t;

// Ключевой материал PWD

/** \brief Тип ключевого материала PWD

    Сеансовый ключ защищается алгоритмом beltKWP при помощи ключа, построенного
    по паролю алгоритмом beltPBKDF2.

    @see keyload_pwd_t - cодержание ключевого материала
    @see keyload_pwd_wrap_t - параметры для защиты сеансового ключа
    @see keyload_pwd_unwrap_t - параметры для снятия защиты сеансового ключа
 */
const cmd_keyload_t* cmdAeadKeyloadPWD();

/*! \brief Тег ключевого материала PWD*/
#define CMD_KEYLOAD_TAG_PWD 0x62

/*! Содержание ключевого материала PWD */
typedef struct {
    octet ekey[CMD_AEAD_KEY_SIZE + 16];         /*!< защищенный сеансовый ключ */
    octet salt[8];                              /*!< "соль" алгоритма beltPBKDF2 */
    size_t iter;                                /*!< число итераций алгоритма beltPBKDF2 */
} keyload_pwd_t;

/*! Параметры защиты сеансового ключа в режиме PWD */
typedef struct {
    octet pwd[256];                 /*!< пароль */
    size_t pwd_len;                 /*!< длина пароля */
    octet salt[8];                  /*!< "соль" алгоритма beltPBKDF2 */
    size_t iter;                    /*!< число итераций алгоритма beltPBKDF2 */
} keyload_pwd_wrap_t;

/*! Параметры снятия защиты сеансового ключа в режиме PWD */
typedef struct {
    octet pwd[256];                 /*!< пароль */
    size_t pwd_len;                 /*!< длина пароля */
} keyload_pwd_unwrap_t;

//Операции с заголовком и ключевым материалом

/*! \brief Защита сеансового ключа

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если защита проведена успешно, и
    код ошибки в обратном случае
 */
err_t cmdAeadWrapKey(
        octet *keload,                        /*!< [out] защищенный ключевой материал */
        const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
        const void *keyload_wrap,             /*!< [in]  параметры защиты */
        const octet key[CMD_AEAD_KEY_SIZE]    /*!< [in]  сеансовый ключ */
);

/*! \brief Снятие защиты сеансового ключа

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если защита снята успешно, и
    код ошибки в обратном случае
 */
err_t cmdAeadUnwrapKey(
        const octet* keyload,                 /*!< [in]  защищенный ключевой материал */
        const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
        const void* keyload_unwrap,           /*!< [in]  параметры снятия защиты */
        octet key[CMD_AEAD_KEY_SIZE]          /*!< [out] сеансовый ключ */
);

/*! \brief Чтение заголовка зашифрованного файла

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если заголовок прочитан успешно, и код
    ошибки в обратном случае
 */
err_t cmdAeadHeaderRead(
        size_t* der_len,                      /*!< [out] длина DER-кода (optional) */
        octet* der,                           /*!< [out] DER-код (optional) */
        cmd_aeadhead_t* header,               /*!< [out] заголовок */
        const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
        const char* file_name                 /*!< [in]  имя файла */
);

/*! \brief Запись заголовка в зашифрованный файл

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовым ключем является общий секретный ключ)

    \return ERR_OK, если заголовок записан успешно, и код
    ошибки в обратном случае
 */
err_t cmdAeadHeaderWrite(
        size_t* der_len,                      /*!< [out] длина DER-кода (optinal) */
        octet* der,                           /*!< [out] DER-код (optinal) */
        const cmd_aeadhead_t* header,         /*!< [in]  заголовок */
        const cmd_keyload_t* keyload_type,    /*!< [in]  тип ключевого материала */
        const char* file_name                 /*!< [in] имя файла */
);

// Шифрование и дешифрование

/*! \brief Аутентифицированное шифрование данных по схеме CHE

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовый ключ защищается на пароле)

    \return ERR_OK, если файл зашифрован успешно, и код ошибки
    в обратном случае
 */
err_t cmdAeadEncrypt(
        const char* file,                       /*!< [in] имя шифруемого файла */
        const char* encrypted_file,             /*!< [in] имя выходного файла */
        size_t itag,                            /*!< [in] период промежуточных имитовставок (МБ) */
        const cmd_keyload_t* keyload_type,      /*!< [in] тип ключевого материала */
        const void* wrap_params,                /*!< [in] параметры для защиты сеансового ключа */
        const char* adata                       /*!< [in] файл с присоединенными данными */
);

/*! \brief Дешифрование аутентифицированного сообщения по схеме CHE

    Стандартные типы ключевого материала:
        cmdAeadKeyloadPKE (сеансовый ключ защищается на открытом ключе получателя),
        cmdAeadKeyloadPWD (сеансовый ключ защищается на пароле)

    \return ERR_OK, если файл расшифрован успешно, и код ошибки
    в обратном случае
 */
err_t cmdAeadDecrypt(
        const char* file,                       /*!< [in] имя зашифрованного файла */
        const char* decrypted_file,             /*!< [in] имя выходного файла */
        const cmd_keyload_t* keyload_type,      /*!< [in] тип ключевого материала */
        const void* unwrap_params,              /*!< [in] параметры для снятия защиты сеансового ключа */
        const char* adata                       /*!< [in] файл с присоединенными данными */
);


#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_CMD_H */
