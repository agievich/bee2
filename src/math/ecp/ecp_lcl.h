/*
*******************************************************************************
\file ecp_lcl.h
\brief Elliptic curves over prime fields: local definitions
\project bee2 [cryptographic library]
\created 2012.06.26
\version 2021.07.29
\license This program is released under the GNU General Public License
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

#include "bee2/math/zm.h"

/*
*******************************************************************************
Общие положения

Реализованные алгоритмы сложения/удвоения/утроения точек (см. модули 
ecp_a.c, ecp_j.c) представлены в ресурсе http://www.hyperelliptic.org/EFD. 
Там же можно найти соглашения по обозначению сложности алгоритмов. 
В этих обозначениях фигурируют следующие формальные выражения:
	add -- сложение или вычитание \mod p,
	c -- умножение на малую константу c (2,3,...) \mod p,
	half -- умножение на 2^{-1} \mod p,
	*A -- умножение на коэффициент A \mod p,
	S -- возведение в квадрат \mod p,
	M -- умножение \mod p,
	D -- деление \mod p.

При общей оценке сложности считается, что 1D = 100M и 1S = 1M.
Аддитивные операции игнорируются.

Используются обозначения:
	A <- A + A -- сложение аффинных точек,
	A <- 2A -- удвоение аффинной точки;
	P <- P + P -- сложение проективных точек;
	P <- P + A -- добавление к проективной точке аффинной;
	P <- 2P -- удвоение проективной точки;
	P <- 2A -- удвоение аффинной точки с переходом к проективным координатам.
*******************************************************************************
*/

/*
*******************************************************************************
Макросы

В макросе ecpSeemsOnA() проверяется, что две координаты входной (аффинной) 
точки лежат в базовом поле. 

В макросе ecpSeemsOn3() проверяется, что три координаты входной (проективной)
точки лежат в базовом поле. Если последняя координата (Z) нулевая, то 
точка считается бесконечно удаленной и первые две координаты не проверяются.
*******************************************************************************
*/

#define ecpSeemsOnA(a, ec)\
	(zmIsIn(ecX(a), (ec)->f) && zmIsIn(ecY(a, (ec)->f->n), (ec)->f))

#define ecpSeemsOn3(a, ec)\
	(wwIsZero(ecZ(a, (ec)->f->n), (ec)->f->n) ||\
	ecpSeemsOnA(a, ec) && zmIsIn(ecZ(a, (ec)->f->n), (ec)->f))
