/*
*******************************************************************************
\file btok_pwd.c
\brief STB 34.101.79 (btok): Password management
\project bee2 [cryptographic library]
\created 2022.07.19
\version 2022.07.21
\license This program is released under the GNU General Public License
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

#include "bee2/core/blob.h"
#include "bee2/core/err.h"
#include "bee2/core/der.h"
#include "bee2/core/mem.h"
#include "bee2/core/hex.h"
#include "bee2/core/rng.h"
#include "bee2/core/str.h"
#include "bee2/core/util.h"
#include "bee2/crypto/btok.h"

/*
*******************************************************************************
# Выдержки из СТБ 34.101.79

1. КТ должен поддерживать три пароля -- PIN, CAN, PUK. Пароли используются
в протоколе BPACE и являются общими для всех прикладных программ КТ.
Пароли записываются на КТ при выпуске токена в обращение. Пароли PIN и PUK
конфиденциально передаются владельцу, CAN передается в открытом виде.

2. Пароль PIN (от Personal Identification Number) представляет собой случайное
число из 6 десятичных цифр, известное только владельцу КТ. Используется для
контроля доступа к данным и прикладным программам КТ. Может быть изменен
владельцем в процессе эксплуатации КТ после ввода верного действующего PIN.

3. PIN снабжается счетчиком попыток, который первоначально равен 3. При
неверном вводе PIN счетчик уменьшается на 1. Если счетчик достигает
значения 1, то PIN приостанавливается и далее требуется ввести CAN.
Ввод CAN не изменяет счетчик. При верном CAN пароль PIN возобновляется --
его снова можно ввести. При неверном CAN доступ к КТ временно блокируется.
Если счетчик попыток достигает значения 0, то блокируется PIN.
При вводе верного PIN счетчик попыток возвращается к значению 3.

4. PIN может быть разблокирован после ввода верного PUK. Однако если при
заблокированном PIN пароль PUK вводится неверно 10 раз, то PIN блокируется
навсегда. При успешной разблокировке PIN счетчик попыток возвращается
к значению 3.

5. PIN может быть деактивирован и повторно активирован с помощью специальных
команд. Для деактивации требуется предъявить верный PIN или PUK,
для активации -- верный PUK. Сразу после выпуска токена PIN активирован.
При деактивации PIN доступ к операциям и данным, требующим аутентификации по
PIN, запрещен. В том числе запрещена аутентификация по PIN, разблокировка PIN.
Деактивация и повторная активация PIN не изменяют ни статус его блокировки,
ни счетчик попыток.

6. Пароль CAN (от Card Access Number) представляет собой число из 6 десятичных
цифр, которое не может быть вычислено на основании общей информации о КТ
(например, серийном номере) или его владельце. Может быть напечатан на корпусе
КТ или указан в сопроводительных документах.

7. Пароль CAN не может быть заблокирован или изменен. Он используется для защиты
от атак типа <<отказ в обслуживании>>. Защита состоит в требовании ввести CAN
перед последней проверкой PIN. Дополнительно CAN может использоваться для
получения доступа к функциям и данным прикладной программы eID
авторизованным терминалом, т. е. терминалом, который был успешно
аутентифицирован с помощью протокола BAUTH и в сертификате которого установлено
соответствующее право.

8. Пароль PUK (от PIN Unlock Key) представляет собой случайное число из 10
десятичных цифр, известное только владельцу КТ. PUK не может быть заблокирован
или изменен. Используется для разблокировки PIN. Дополнительно может
использоваться для деактивации и активации PIN.

9. После ввода неверного CAN или PUK следует временно заблокировать КТ не менее
чем на 1 с. Для контроля времени блокировки следует использовать аппаратный
таймер либо организовать вычисления требуемой продолжительности.

10. При передаче в команды КТ пароли PIN, CAN и PUK представляются строками
октетов, в которых октет 0x30 кодирует цифру 0 пароля, октет 0x31 -- цифру 1,
..., октет 0x39 -- цифру 9.
*******************************************************************************
*/

/*
*******************************************************************************
# Комментарии (реконструкция нераскрытых в СТБ тем)

1. Успешная аутентификация по одному из паролей PIN, CAN, PUK отменяет
статус успешной аутентификации по другому паролю. Нельзя быть одновременно
аутентифицированным по двум паролям.

2. После успешной аутентификация по одному из паролей PIN, CAN, PUK можно
повторно аутентифицироваться по этому же паролю. В случае успеха статус
успешной аутентификации по паролю будет сохранен, в случае ошибки -- потерян.

3. После успешной аутентификация по одному из паролей PIN, CAN, PUK можно
аутентифицироваться по другому паролю. В случае успеха статус успешной
аутентификации по первому паролю будет потерян, в случае ошибки -- сохранен.

4. Даже если PIN заблокирован навсегда, аутентификация по PUK (и тем более по
CAN) остается возможной.

5. Статус успешной аутентификации по CAN должен действовать непосредственно
в момент последней попытки ввода PIN. Иначе эта попытка отменяется.
*******************************************************************************
*/

/*
*******************************************************************************
Автомат

Состояние автомата состоит из двух частей: pin_state и auth_state.

Первая часть (pin_state) описывает состояние PIN и принимает значения
из множества:
  {puk0, puk1,...., puk9, pin0, pin1, pind, pins, pin2, pin3}.
Семантика состояний:
- в состояниях pinN остается N попыток ввода PIN, при этом pin0 -- состояние
  блокировки PIN;
- в состояниях pukN PIN заблокирован и остается N попыток ввода PUK для его
  разблокировки. При этом puk0 -- состояние полной блокировки PIN;
- состояние pins (suspended) является промежуточным между pin2 и pin1:
  переход pin2 => pins выполняется при ошибке аутентификации по PIN,
  а переход pins => pin1 -- при успешной аутентификации по CAN;
- состояние pind (deactivated) -- это состояние принудительной деактивации PIN.

Подсостояние pin_state сохраняется между сеансами работы с автоматом. Начальное
("заводское") значение pin_state: pin3.

Вторая часть состояния (auth_state) описывает статус аутентификации и принимает
значения из множества:
  {auth_none, auth_pin, auth_can, auth_puk}.
Семантика статусов:
- auth_XXX: успешная аутентификация по паролю XXX;
- auth_none: без аутентификации.

Подсостояние auth_state не сохраняется между сеансами работы с автоматом.
Подсостояние полагается равным auth_none в начале каждого сеанса.

Автомат обрабатывает события из следующего множества:
  { pin_ok, pin_bad, pin_deactivate, pin_activate,
    can_ok, can_bad,
	puk_ok, puk_bad,
    auth_close, }.
Семантика событий:
- XXX_ok: успешная аутентификация по паролю XXX;
- XXX_bad: ошибка аутентификации по паролю XXX;
- pin_deactivate: деактивация PIN;
- pin_activate: активация PIN после деактивации;
- auth_close: отмена аутентификации.

\remark Команд отмены аутентификации нет. Речь может идти о неявной отмене
(например, через переключение на соединение с терминалом). События auth_close
под вопросом.

\remark "Деактивация и повторная активация PIN не изменяют ни статус его
блокировки, ни счетчик попыток." Деактивация выполняется после успешной
аутентификации по PIN или PUK. Но тогда pin_state обязательно равняется pin3.
При этом PIN не заблокирован (pin_state != pin0). Из состояния деактивации
pind мы выходим только по puk_ok. При этом разрешается аутентифицироваться
по PUK произвольное число раз. Из состояния блокировки pin0 мы также выходим
только по puk_ok. Но число попыток ограничено. Только в этом разница между
pind и pin0.
*******************************************************************************
*/

typedef enum
{
	puk0,													/* terminated */
	puk1, puk2, puk3, puk4, puk5, puk6, puk7, puk8, puk9,	/* puk attempts */
	pin0,													/* locked */
	pin1,													/* last attempt */
	pind,													/* deactivated */
	pins,													/* suspended */
	pin2,													/* two attempts */
	pin3,													/* operational */
} btok_pin_state;

typedef enum
{
	auth_none,
	auth_pin,
	auth_can,
	auth_puk,
} btok_auth_state;

typedef enum
{
	pin_ok, pin_bad, pin_deactivate, pin_activate,
	can_ok, can_bad, 
	puk_ok, puk_bad,
	auth_close, 
} btok_pwd_event;

typedef struct
{
	btok_pin_state pin : 4;
	btok_auth_state auth : 2;
} btok_pwd_state;

bool_t btokPwdTransition(btok_pwd_state* state, btok_pwd_event event)
{
	ASSERT(memIsValid(state, sizeof(btok_pwd_state)));
	switch (event)
	{
	case auth_close:
		if (state->auth == auth_none)
			return FALSE;
		state->auth = auth_none;
		return TRUE;
	case pin_deactivate:
		if (state->auth != auth_pin && state->auth != auth_puk)
			return FALSE;
		state->pin = pind;
		if (state->auth == auth_pin)
			state->auth = auth_none;
		return TRUE;
	case pin_activate:
		if (state->pin != pind || state->auth != auth_puk)
			return FALSE;
		state->pin = pin3;
		return TRUE;
	case can_ok:
		if (state->pin == pins)
			state->pin = pin1;
		state->auth = auth_can;
		return TRUE;
	case can_bad:
		if (state->auth == auth_can)
			state->auth = auth_none;
		return TRUE;
	case puk_ok:
		if (puk1 <= state->pin && state->pin <= pin0)
			state->pin = pin3;
		state->auth = auth_puk;
		return TRUE;
	case puk_bad:
		if (puk1 <= state->pin && state->pin <= pin0)
			--state->pin;
		if (state->auth == auth_puk)
			state->auth = auth_none;
		return TRUE;
	case pin_ok:
		if (state->pin != pin1 && state->pin != pin2 && state->pin != pin3)
			return FALSE;
		state->pin = pin3;
		state->auth = auth_pin;
		return TRUE;
	case pin_bad:
		if (state->pin != pin1 && state->pin != pin2 && state->pin != pin3)
			return FALSE;
		--state->pin;
		if (state->auth == auth_pin)
			state->auth = auth_none;
		return TRUE;
	}
	return FALSE;
}
