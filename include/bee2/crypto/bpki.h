/*
*******************************************************************************
\file bpki.h
\brief STB 34.101.78 (bpki): PKI helpers
\project bee2/apps/bpki
\author Sergey Agievich [agievich@{bsu.by|gmail.com}]
\author Vlad Semenov [semenov.vlad.by@gmail.com]
\created 2021.04.03
\version 2022.06.16
\license This program is released under the GNU General Public License
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

#ifndef __BEE2_BPKI_H
#define __BEE2_BPKI_H

#include "bee2/defs.h"

/*!
*******************************************************************************
\file bpki.h
\brief Механизмы СТБ 34.101.78 (bpki)
*******************************************************************************
*/


#ifdef __cplusplus
extern "C" {
#endif

/*!
*******************************************************************************
\file bpki.h

Реализованы отдельные механизмы СТБ 34.101.78 (bpki):
-	управление контейнерами с личными ключами СТБ 34.101.45 (bign);
-	управление контейнерами с частичными секретами СТБ 34.101.60 (bels).

Формат контейнера с личным ключом описывается типом EncryptedPrivateKeyInfo,
определенным в PKCS#8 (RFC 5208). Для защиты контейнера используется механизм
PBKDF2, определенный в PKCS#5 (RFC 8018). Формат и механизм уточняются
в СТБ 34.101.78.

Секретным параметром PBKDF2 является пароль. Для повышения гарантий защиты
в качестве пароля может выступать полноценный ключ. Этот ключ разделяется
на частичные секреты, которые также сохраняются в контейнерах
EncryptedPrivateKeyInfo будучи защищенными на обычных паролях.

При разделении на частичные секреты используются стандартные параметры bels,
в частности, стандартные открытые ключи. Номер открытого ключа (число от 1
до 16) кодируется октетом и добавляется в начало частичного секрета.
Поэтому длина частичного секрета в октетах на единицу больше стандартной
длины (17 вместо 16, 25 вместо 24 и 33 вместо 32).

\expect{ERR_BAD_INPUT} Все входные указатели действительны. Исключение
составляют случаи, когда нулевой указатель передается как запрос на определение
объема памяти, которую требуется зарезервировать при повторном вызове
(конструкция [len?]ptr).  
*******************************************************************************
*/

/*!	\brief Создание контейнера с личным ключом

	Создается  контейнер [epki_len?]epki с защищенным личным ключом
	[privkey_len]privkey. Ключ защищается на пароле [pwd_len]pwd.
	Используется механизм защиты PBKDF2 с синхропосылкой ("солью") salt
	и числом итераций iter.
	\expect{ERR_BAD_PRIVKEY} privkey_len \in {32, 48, 64}.
	\expect{ERR_BAD_INPUT} iter >= 10000.
	\return ERR_OK, если контейнер успешно создан, и код ошибки в противном
	случае.
	\remark При нулевом epki указатели privkey, pwd и salt могут быть нулевыми.
*/

err_t bpkiWrapPrivkey(
    octet epki[],			/*!< [out] контейнер с личным ключом */
	size_t* epki_len,		/*!< [out] длина epki */
	const octet privkey[],	/*!< [in] личный ключ */
    size_t privkey_len,		/*!< [in] длина privkey */
    const octet pwd[],		/*!< [in] пароль */
    size_t pwd_len,			/*!< [in] длина pwd */
	const octet salt[8],	/*!< [in] синхропосылка ("соль") PBKDF2 */
	size_t iter				/*!< [in] количество итераций в PBKDF2 */
);

/*!	\brief Разбор контейнера с личным ключом

	Из контейнера [epki_len]epki извлекается личный ключ [privkey_len?]privkey,
	защищенный с помощью механизма PBKDF2. Защита снимается на пароле
	[pwd_len]pwd.
	\return ERR_OK, если личный ключ успешно извлечен, и код ошибки в противном
	случае.
	\remark Формально для определения длины privkey_len личного ключа нужно
	снять защиту, а для этого предъявить пароль. Поэтому указатель pwd должен
	быть корректен даже при нулевом указателе privkey, т.е. во время запроса
	длины privkey_len. Здесь не учитывается, что длину личного ключа можно
	определить косвенно по длине контейнера.
*/

err_t bpkiUnwrapPrivkey(
	octet privkey[],		/*!< [out] личный ключ */
	size_t* privkey_len,	/*!< [in] длина privkey */
	const octet epki[],		/*!< [in] контейнер с личным ключом */
	size_t epki_len,		/*!< [in] длина epki */
	const octet pwd[],		/*!< [in] пароль */
	size_t pwd_len			/*!< [in] длина pwd */
);

/*!	\brief Создание контейнера с частичным секретом

	Создается  контейнер [epki_len?]epki с защищенным частичным секретом
	[share_len]share. Ключ защищается на пароле [pwd_len]pwd.
	Используется механизм защиты PBKDF2 с синхропосылкой ("солью") salt
	и числом итераций iter.
	\expect{ERR_BAD_SHAREKEY} share_len \in {17, 25, 33}.
	\expect{ERR_BAD_SHAREKEY} Если share != 0, то 1 <= share[0] <= 16.
	\expect{ERR_BAD_INPUT} iter >= 10000.
	\return ERR_OK, если контейнер успешно создан, и код ошибки в противном
	случае.
	\remark В префиксе частичного секрета указывается номер соответствующего 
	открытого ключа (из стандартного списка открытых ключей). Открытый ключ
	используется при сборке ключа по частичным секретам. 
	\remark При нулевом epki указатели share, pwd и salt могут быть нулевыми.
*/

err_t bpkiWrapShare(
	octet epki[],			/*!< [out] контейнер с частичным секретом */
	size_t* epki_len,		/*!< [out] длина epki */
	const octet share[],	/*!< [in] частичный секрет */
	size_t share_len,		/*!< [in] длина share */
	const octet pwd[],		/*!< [in] пароль */
	size_t pwd_len,			/*!< [in] длина pwd */
	const octet salt[8],	/*!< [in] синхропосылка ("соль") PBKDF2 */
	size_t iter				/*!< [in] количество итераций в PBKDF2 */
);

/*!	\brief Разбор контейнера с частичным секретом

	Из контейнера [epki_len]epki извлекается частичный секрет
	[share_len?]share, защищенный с помощью механизма PBKDF2. Защита
	снимается на пароле [pwd_len]pwd.
	\expect{ERR_BAD_SECKEY} Если share != 0, то 1 <= share[0] <= 16.
	\return ERR_OK, если частичный секрет успешно извлечен, и код ошибки
	в противном случае.
	\remark Формально для определения длины share_len частичного секрета нужно
	снять защиту, а для этого предъявить пароль. Поэтому указатель pwd должен
	быть корректен даже при нулевом указателе share, т.е. во время запроса длины
	share_len. Здесь не учитывается, что длину частичного секрета можно определить
	косвенно по длине контейнера.
*/
err_t bpkiUnwrapShare(
	octet share[],			/*!< [out] частичный секрет */
	size_t* share_len,		/*!< [out] длина share */
	const octet epki[],		/*!< [in] контейнер с частичным секретом */
	size_t epki_len,		/*!< [in] длина epki */
	const octet pwd[],		/*!< [in] пароль */
	size_t pwd_len			/*!< [in] длина pwd */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /*__BEE2_BPKI_H */
