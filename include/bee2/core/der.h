/*
*******************************************************************************
\file der.h
\brief Distinguished Encoding Rules
\project bee2 [cryptographic library]
\author Sergey Agievich [agievich@{bsu.by|gmail.com}]
\author Vlad Semenov [semenov.vlad.by@gmail.com]
\created 2014.04.21
\version 2021.04.21
\license This program is released under the GNU General Public License 
version 3. See Copyright Notices in bee2/info.h.
*******************************************************************************
*/

/*!
*******************************************************************************
\file der.h
\brief Отличительные правила кодирования
*******************************************************************************
*/

#ifndef __BEE2_DER_H
#define __BEE2_DER_H

#include "bee2/defs.h"

#ifdef __cplusplus
extern "C" {
#endif

/*!
*******************************************************************************
\file der.h DER-кодирование

\section der-enc Правила кодирования

Поддержано кодирование по правилам АСН.1. Согласно этим правилам, структуры 
данных представляются в формате TLV: сначала идет октеты тега (T), затем 
октеты длины (L), а после этого L октетов значения (V).

Тег задается, как минимум, одним октетом, в котором младшие 5 битов
представляют номер, 6-й бит является признаком примитивности /
конструктивности (если бит установлен, то V не содержит / содержит
вложенные структуры TLV), а старшие два бита определяют класс тега.

Если не все 5 младших битов первого октета тега равняются 1,
то первый октет является единственным (короткий тег). Короткие теги
могут иметь номера от 0 до 30.

Если все 5 младших битов типа первого октета тега равняются 1
(длинный тег), то номер тега представляется в виде
	\sum {i = 0}^{r - 1}t_i 128^i, 0 <= t_i < 128, t_{r - 1} != 0,
и кодируется октетами
	(t_{r - 1} | 128), ..., (t_1 | 128), t_0,
следующими сразу за первым октетом тега.

Длинные теги должен применяться только для номеров >= 31. В частности,
если r == 1, то t_0 >= 31.

Ограничение реализации: тег задается словом u32. Номер тега задается
младшими 5 битами слова, если не все эти биты единичные (короткий тег),
либо старшими 24 битами, в противном случае (длинный тег). Если в коротком
теге некоторый из старших 24 битов ненулевой, то это считается ошибкой
формата. Если в длинном теге старшие 24 бита соответствуют числу < 31, то
это также считается ошибкой формата.

Если L < 128, то длина может кодироваться одним октетом, содержащим L
(короткая явная форма). Если L >= 128, то длина представляется в виде
	L = \sum {i = 0}^{r - 1}l_i 256^i, 0 <= l_i < 256,
и кодируется r + 1 октетами
	(r | 128), l_{r - 1},..., l_0
(длинная явная форма). Заранее неизвестная длина кодируется октетом 128
(неявная форма). Значение 255 первого октета длины зарезервировано и не
должно использоваться.

При кодировании примитивных типов (см. 6-й бит тега) должна использоваться
явная форма длины. Других ограничений в базовых правилах кодирования АСН.1,
которые называются BER (Basic Encoding Rules), нет. Например, допускается
выбор длинной формы для L < 128, допускается использование в длинной
форме нулевых старших октетов (l_{r - 1} может равняться 0).

Реализованные в настоящем модуле правила DER (Distinguished Encoding Rules) 
снимают неоднозначности. По правилам DER длина должна кодироваться всегда 
в явной форме и всегда с помощью минимального числа октетов. Последнее 
означает, что при L < 128 должна применяться короткая форма, 
а при L >= 128 -- длинная форма с l_{r - 1} != 0.

Ограничение реализации: длина укладывается в size_t.

Декодируемый DER-код записывается в виде [<=count]der.
Подразумевается, что код записан в префиксе буфера [count]der.
Точная длина DER-кода (сумма длин полей T, L и V, причем длина V указана в L)
определяется в процессе декодирования.
*******************************************************************************
*/

/*!	\brief Кодирование

	Определяется число октетов в DER-коде значения [len]val с тегом tag. 
	Если der != 0, то DER-код размещается по этому адресу.
	\pre Если der != 0, то val != 0 и по адресу der зарезервировано
	derEnc(0, tag, val, len) октетов.
	\return Число октетов в DER-коде или SIZE_MAX в случае ошибки.
	\remark Ошибкой является неверный формат tag.
	\remark Разрешаются вызовы derEnc(0, tag, val, len),
	derEnc(0, tag, 0, len).
*/
size_t derEnc(
	octet der[],		/*!< [out] DER-код */
	u32 tag,			/*!< [in] тег */
	const void* val,	/*!< [in] значение */
	size_t len			/*!< [in] длина val в октетах */
);

/*!	\brief Корректный код?

	Проверяется корректность DER-кода [count]der. Проверяются следующие 
	условия:
	- тег T и длина L закодированы по правилам ACH.1;
	- тег укладывается в u32 (ограничение реализации);
	- длина укладывается в size_t (органичение реализации);
	- count действительно является длиной кода.
	\return Признак корректности.
	\remark Содержимое V не проверяется.
*/
bool_t derIsValid(
	const octet der[],	/*!< [in] DER-код */
	size_t count		/*!< [in] длина der в октетах */
);

/*!	\brief Корректный код с ожидаемым тегом?

	Проверяется корректность DER-кода [count]der с ожидаемым тегом tag. 
	Проверяются следующие условия:
	-	derIsValid(der, count) == TRUE;
	-	der имеет тег tag.
	\return Признак корректности.
	\remark Содержимое V не проверяется.
*/
bool_t derIsValid2(
	const octet der[],	/*!< [in] DER-код */
	size_t count,		/*!< [in] длина der в октетах */
	u32 tag				/*!< [in] ожидаемый тег */
);

/*!	\brief Декодирование

	Определяются тег tag и значение [len?]val DER-кода [<=count]der.
	При этом val указывает на буфер памяти внутри буфера der.
	\remark Любой из указателей tag, val, len может быть нулевым, и тогда
	возврат данных по указателю не производится.
	\pre Буферы, на которые ссылаются ненулевые указатели tag, val и len,
	не пересекаются между собой и с буфером der.
	\return Точная длина DER-кода или SIZE_MAX в случае оишбки формата.
*/
size_t derDec(
	u32* tag,				/*!< [out] тег */
	const octet** val,		/*!< [out] указатель на значение */
	size_t* len,			/*!< [out] длина значения */
	const octet der[],		/*!< [in] DER-код */
	size_t count			/*!< [in] длина der в октетах */
);

/*!	\brief Декодирование с проверкой тега

	Проверяется, что тег DER-кода [<=count]der равняется tag и, если это так,
	определяется закодированное значение [len?]val. При этом val указывает
	на буфер памяти внутри буфера der.
	\remark Любой из указателей val, len может быть нулевым, и тогда возврат
	данных по указателю не производится.
	\pre Буферы, на которые ссылаются ненулевые указатели val и len,
	не пересекаются между собой и с буфером der.
	\return Точная длина DER-кода или SIZE_MAX в случае ошибки.
*/
size_t derDec2(
	const octet** val,		/*!< [out] значение */
	size_t* len,			/*!< [out] длина значения */
	const octet der[],		/*!< [in] DER-код */
	size_t count,			/*!< [in] длина der в октетах */
	u32 tag					/*!< [in] тег */
);

/*!	\brief Декодирование с проверкой тега и длины

	Проверяется, что тег и длина значения DER-кода [<=count]der равняются
	соответственно tag и len и, если это так, определяется закодированное
	значение [len]val. При этом val указывает на буфер памяти внутри
	буфера der.
	\remark Указатель val может быть нулевым, и тогда возврат данных по
	указателю не производится. 
	\pre Если val != 0, то соответствующий буфер не пересекается с буфером der.
	\return Точная длина DER-кода или SIZE_MAX в случае ошибки.
*/
size_t derDec3(
	const octet** val,		/*!< [out] значение */
	const octet der[],		/*!< [in] DER-код */
	size_t count,			/*!< [in] длина der в октетах */
	u32 tag,				/*!< [in] тег */
	size_t len				/*!< [in] длина значения */
);

/*!	\brief Проверка кода

	Проверяется, что тег и значение DER-кода [<=count]der равняются
	соответственно tag и [len]val.
	\remark Величина count является оценкой сверху актуальной длины DER-кода.
	\return Точная длина DER-кода или SIZE_MAX в случае ошибки.
*/
size_t derDec4(
	const octet der[],		/*!< [in] DER-код */
	size_t count,			/*!< [in] длина der в октетах */
	u32 tag,				/*!< [in] тег */
	const void* val,		/*!< [in] значение */
	size_t len				/*!< [in] длина значения */
);

/*!
*******************************************************************************
\file der.h DER-кодирование

\section der-base Базовые типы

Реализовано кодирование следующих типов АСН.1:
- INTEGER (0x02, SIZE);
- OCTET STRING (0x04, OCT);
- NULL (0x05, NULL);
- OBJECT IDENTIFIER (0x06, OID);
- SEQUENCE (0x30, SEQ).

В скобках указывается тег типа и короткое имя. Короткое имя входит в название
функций и макросов работы с типом.

Для типа INTEGER реализована работа только с неотрицательными значениями,
которые укладываются в size_t.

Идентификатор объекта задается строкой по правилам модуля oid.h.

При кодировании контейнера (структуры SEQUENCE) длина вложенных данных
становится окончательно известна только в конце кодирования. Для уточнения
длины в начале кодирования сохраняется ссылка на закодированный префикс
структуры. Эта ссылка называется якорем, описывается типом der_anchor и
используется при завершении кодирования.

Якорь используется также при декодировании контейнера: сохраняется в начале,
учитывается в конце для проверки кода.

\remark Значение, которое определяется при декодировании SIZE, OCT и OID,
возвращается по указанному извне адресу, а не в виде указателя
на участок декодируемого кода (ср. с поведением базовых функций derDecXXX()).
*******************************************************************************
*/

/*!	\brief Кодирование SIZE

	Определяется число октетов в DER-коде неотрицательного целого (INTEGER)
	val типа size_t. Если der != 0, то DER-код размещается по этому адресу.
	\pre Если der != 0, то по адресу der зарезервировано derEncSIZE(0, val)
	октетов.
	\return Число октетов в DER-коде или SIZE_MAX в случае ошибки.
*/
size_t derEncSIZE(
	octet der[],	/*!< [out] DER-код */
	size_t val		/*!< [in] значение */
);

/*!	\brief Декодирование SIZE

	Определяется неотрицательное целое (INTEGER) val, представленное
	DER-кодом [<=count]der.
	\remark Указатель val может быть нулевым, и тогда возврат данных
	по указателю не производится.
	\return Точная длина DER-кода или SIZE_MAX в случае оишбки.
*/
size_t derDecSIZE(
	size_t* val,		/*!< [out] значение */
	const octet der[],	/*!< [in] DER-код */
	size_t count		/*!< [in] длина der в октетах */
);

/*!	\brief Проверка кода SIZE

	Проверяется, что DER-код [<=count]der представляет неотрицательное
	целое (INTEGER) типа size_t.
	\return Точная длина DER-кода или SIZE_MAX в случае оишбки.
*/
size_t derDecSIZE2(
	const octet der[],	/*!< [in] DER-код */
	size_t count,		/*!< [in] длина der в октетах */
	size_t val			/*!< [in] значение */
);

/*!	\brief Кодирование OCTET STRING */
#define derEncOCT(der, val, len) derEnc(der, 0x04, val, len)

/*!	\brief Декодирование OCTET STRING

	Определяется строка октетов [len?]buf, представленная DER-кодом
	[<=count]der. 
	\return Точная длина DER-кода или SIZE_MAX в случае ошибки.
*/
size_t derDecOCT(
	octet* val,			/*!< [out] строка октетов */
	size_t* len,		/*!< [out] длина val */
	const octet der[],	/*!< [in] DER-код */
	size_t count		/*!< [in] длина der в октетах */
);

/*!	\brief Декодирование OCTET STRING с проверкой длины

	Проверяется, что DER-код [<=count]der представляет строку октетов
	длины len и, если это так, определяется закодированное
	значение [len]val.
	\remark Указатель val может быть нулевым, и тогда возврат данных по
	указателю не производится.
	\pre Если val != 0, то соответствующий буфер не пересекается с буфером der.
	\return Точная длина DER-кода или SIZE_MAX в случае ошибки.
*/
size_t derDecOCT2(
	octet* val,			/*!< [out] строка октетов */
	const octet der[],	/*!< [in] DER-код */
	size_t count,		/*!< [in] длина der в октетах */
	size_t len			/*!< [in] длина val */
);

/*!	\brief Проверка кода OCTET STRING */
#define derDecOCT3(der, count, val, len) derDec4(der, count, 0x04, val, len)

/*!
*******************************************************************************
\def derEncNULL
\brief Кодирование NULL

\def derDecNULL
\brief Проверка кода NULL
*******************************************************************************
*/

/*! \brief Кодирование NULL */
#define derEncNULL(der) derEnc(der, 0x05, 0, 0)

/*! \brief Проверка кода NULL */
#define derDecNULL(der, count) derDec4(der, count, 0x05, 0, 0)

/*!	\brief Кодирование OBJECT IDENTIFIER

	Определяется число октетов в DER-коде идентификатора объекта oid.
	Если der != 0, то DER-код размещается по этому адресу.
	\pre Если der != 0, то по адресу der зарезервировано derEncOID(0, oid)
	октетов.
	\return Число октетов в DER-коде или SIZE_MAX в случае ошибки.
*/

size_t derEncOID(
	octet der[],		/*!< [out] DER-код */
	const char* oid		/*!< [in] идентификатор объекта */
);

/*!	\brief Декодирование OBJECT IDENTIFIER

	Определяется идентификатор объекта [len?]oid,
	представленный DER-кодом [<=count]der. Длина len учитывает
	завершающий нулевой символ строки oid.
	\return Точная длина DER-кода или SIZE_MAX в случае ошибки.
*/
size_t derDecOID(
	char* oid,			/*!< [out] идентификатор */
	size_t* len,		/*!< [out] длина идентификатора */
	const octet der[],	/*!< [in] DER-код */
	size_t count		/*!< [in] длина der в октетах */
);

/*!	\brief Проверка кода OBJECT IDENTIFIER

	Проверяется, что DER-код [<=count]der построен по идентификатору oid.
	Идентификатор задается строкой, составленной по правилам модуля oid.h.
	\return Точная длина DER-кода или SIZE_MAX в случае оишбки.
*/
size_t derDecOID2(
	const octet der[],	/*!< [in] DER-код */
	size_t count,		/*!< [in] длина der в октетах */
	const char* oid		/*!< [in] идентификатор */
);

/*!	\brief Якорь для кодирования контейнеров */
typedef struct
{
	const octet* der;	/*!< код */
	size_t pos;			/*!< позиция */
	size_t len;			/*!< длина */
} der_anchor;

/*!	\brief Начать кодирование SEQUENCE

	Определяется число октетов в префиксе DER-кода структуры SEQUENCE.
	Если der != 0, то префикс размещается по этому адресу. Одновременно
	в якоре anchor сохраняются данные, необходимые для уточнения префикса
	при завершении кодирования структуры. Чтобы корректно уточнить префикс
	при нулевом der, в функцию передается параметр pos. Это текущая позиция
	в коде в абстрактной (со свободной точкой отсчета) системе координат.
	\pre Если der != 0, то по адресу der зарезервировано
	derEncSEQStart(anchor, 0, pos) октетов.
	\return Число октетов в префиксе DER-коде или SIZE_MAX в случае ошибки.
	\remark Позиция pos -- это 
*/
size_t derEncSEQStart(
	der_anchor* anchor,		/*!< [out] якорь */
	octet der[],			/*!< [out] DER-код */
	size_t pos				/*!< [out] позиция */
);

/*!	\brief Завершить кодирование SEQUENCE

	По якорю anchor и текущей позиции pos в коде определяется дополнительное
	число октетов для завершения кодирования структуры SEQUENCE. Если der != 0,
	то кодирование завершается.
	\pre Если der != 0, то по адресу der зарезервировано
	derEncSEQStop(0, pos, anchor) октетов.
	\expect derEncSEQStop < derEncSEQStart.
	\pre Если в derEncSEQStart() передан ненулевой адрес der, то в
	derEncSEQStop() также передан ненулевой адрес и разность адресов совпадает
	с разностью позиций.
	\return Число октетов завершающих кодирование или SIZE_MAX в случае	ошибки.
*/
size_t derEncSEQStop(
	octet der[],				/*!< [out] DER-код */
	size_t pos,					/*!< [in] позиция */
	const der_anchor* anchor	/*!< [in] якорь */
);

/*!	\brief Начать декодирование SEQUENCE

	Определяется число октетов в префиксе DER-кода [<=count]der структуры
	SEQUENCE. Одновременно в якоре anchor сохраняются данные, необходимые
	для проверки префикса при завершении декодирования структуры.
	\return Число октетов в префиксе DER-коде или SIZE_MAX в случае ошибки.
*/
size_t derDecSEQStart(
	der_anchor* anchor,			/*!< [out] якорь */
	const octet der[],			/*!< [in] DER-код */
	size_t count				/*!< [in] длина der в октетах */
);

/*!	\brief Завершить декодирование SEQUENCE

	Завершается декодирования структуры SEQUENCE: по якорю anchor,
	сохраненному в начале кодирования, и адресу der, который указывает
	на окончание DER-кода, проверяется корректность кода.
	\pre derDecSEQStop < derDecSEQStart.
	\return 0 в случае успешного завершения или SIZE_MAX в случае ошибки.
*/
size_t derDecSEQStop(
	const octet der[],			/*!< [in] DER-код */
	const der_anchor* anchor	/*!< [in] якорь */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_DER_H */
