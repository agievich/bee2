/*
*******************************************************************************
\file toml.h
\brief TOML files processing
\project bee2 [cryptographic library]
\created 2023.07.12
\version 2024.02.26
\copyright The Bee2 authors
\license Licensed under the Apache License, Version 2.0 (see LICENSE.txt).
*******************************************************************************
*/

/*!
*******************************************************************************
\file toml.h
\brief Формат TOML
*******************************************************************************
*/

#ifndef __BEE2_TOML_H
#define __BEE2_TOML_H

#ifdef __cplusplus
extern "C" {
#endif

#include "bee2/defs.h"

/*!
*******************************************************************************
\file toml.h

Реализовано управление контейнерами формата TOML (Tom's Obvious Minimal 
Language, см. https://toml.io).

Контейнер TOML состоит из секций, секции состоят из пар "ключ -- значение".
Имена секций окаймляются квадратными скобками, ключ и значение разделяются
знаком равенства:
\code
  [section]
  key = value
\endcode

\remark Строго говоря, секции в TOML называются таблицами.

\remark Одно из правил TOML гласит, что в контейнере не должна дважды 
повторяться одна и таже секция и в секции не должен дважды повторяться 
один и тот же ключ. Это правило игнорируется.

Имена секций и ключей бывают трех типов:
- базовое имя (bare name) -- непустое слово в алфавите [0-9a-zA-Z_-];
- имя в кавычках (quoted name) -- слово в произвольном алфавите, окаймленные
  кавычками (двойными или одинарными). Допускается (но не рекомендуются)
  пустое имя в кавычках;
- имя с точками (dotted names) -- последовательность базовых имен и имен
  в кавычках, разделенных точками. Допускается (но не рекомендуются) наличие
  пробелов между именами и точками.

Реализовано управление значениями следующих типов:

1. Строка октетов (octs). Представляет фрагмент памяти, который, в свою
   очередь, может интерпретироваться как неотрицательное целое (по правилам
   little-endian). Каждый октет кодируется двумя шестнадцатеричными символами.
   Код предваряется префиксом "0x". 
2. Неотрицательное целое число (size). Кодируется десятичными символами.
   Поддерживаются числа, которые укладываются в size_t.
3. Список неотрицательных целых чисел (sizes). Коды отдельных чисел
   объединяются с разделителями-запятыми, составной код окаймляется
   квадратными скобками.

Допускается пустая строка октетов, код которой -- "0x".

В списке неотрицательных целых допускается завершающая запятая (trailing comma) 
перед закрывающей скобкой. Допускается пустой список: "[]" или "[,]".

Запись в контейнеры TOML выполняется в два этапа:
- сначала с помощью функции tomlXXXEnc() формируется строка -- значение
  определенного типа;
- затем с помощью функции tomlValSet() полученная строка записывается
  в качестве значения определенного ключа определенной секции определенного
  контейнера.

Чтение из контейнеров TOML выполняется в обратном порядке:
- cначала с помощью функции tomlValGet() прочитывается строка-значение;
- затем с помощью функции tomlXXXDec() прочитанная строка декодируется.

*******************************************************************************
*/

/*!	\brief Корректное имя?

	Проверяется корректность TOML-имени name.
	\return Признак корректности.
*/
bool_t tomlNameIsValid(
	const char* name		/*< [in] имя */
);

/*!	\brief Запись значения ключа

	В ключ key секции section контейнера toml записывается значение val.
	При этом:
	- если секция section отсутствует в контейнере toml, то она создается;
	- если key == 0, то секция section удаляется из контейнера toml;
	- если ключ key отсутствует в секции section, то он создается;
	- если val == 0, то ключ key удаляется из секции section.
	\expect{ERR_BAD_NAME} tomlNameIsValid(section).
	\expect{ERR_BAD_NAME} key == 0 || tomlNameIsValid(key).
	\return ERR_OK в случае успеха и код ошибки в противном случае.
	\remark В контейнере может быть несколько одноименных секций, в секциях 
	может быть несколько одноименных ключей. Описанные действия применяются
	к первой секции section и к первому ключу key в этой секции.
*/
err_t tomlValSet(
	const char* toml,		/*< [in] контейнер */
	const char* section,	/*< [in] секция */
	const char* key,		/*< [in] ключ */
	const char* val			/*< [in] значение */
);

/*!	\brief Чтение значения ключа

	Определяется значение [?count]val ключа key секции section контейнера 
	toml.
	\expect{ERR_BAD_NAME} tomlIsValidName(section) && tomlIsValidName(key).
	\return ERR_OK в случае успеха и код ошибки в противном случае.
	\remark В контейнере может быть несколько одноименных секций, в секциях 
	может быть несколько одноименных ключей. Определяется значение первого 
	ключа с именем key в первой секции с именем section.
*/
err_t tomlValGet(
	char* val,				/*< [out] значение */
	size_t* count,			/*< [in,out] длина val */
	const char* toml,		/*< [in] контейнер */
	const char* section,	/*< [in] секция */
	const char* key			/*< [in] ключ */
);

/*
*******************************************************************************
Кодирование
*******************************************************************************
*/

/*!	\brief Кодирование строки октетов

	Определяется число символов в TOML-коде строки октетов [count]val.
	Если toml != 0, то TOML-код размещается по этому адресу.
	\pre Если toml != 0, то по адресу toml зарезервировано
	tomlOctsEnc(0, val, count) + 1 символов.
	\return Длина кода или SIZE_MAX в случае ошибки.
*/
size_t tomlOctsEnc(
	char* toml,				/*< [out] код */
	const octet* val,		/*< [in] строка октетов */
	size_t count			/*< [in] длина val */
);

/*!	\brief Декодирование строки октетов

	Определяется строка октетов [count?]val, закодированная в префиксе
	TOML-кода toml.
	\remark Любой из указателей val и count может быть нулевым.
	\pre Буферы, на которые ссылаются ненулевые указатели val и count,
	не пересекаются между собой, но могут пересекаться с буфером toml.
	\return Точная длина кода или SIZE_MAX в случае ошибки.
	\remark При декодировании пропускаются предваряющие и завершающие 
	пробелы. Их количество учитывается в возвращаемом значении.
	\remark Код "0x" соответствует пустой строке октетов.
*/
size_t tomlOctsDec(
	octet* val,				/*< [out] строка октетов */
	size_t* count,			/*< [out] длина val */
	const char* toml		/*< [in] код */
);

/*!	\brief Кодирование неотрицательного целого

	Определяется число символов в TOML-коде неотрицательного целого val.
	Если toml != 0, то TOML-код размещается по этому адресу.
	\pre Если toml != 0, то по адресу toml зарезервировано
	tomlSizeEnc(0, val) + 1 символов.
	\return Число октетов в TOML-коде или SIZE_MAX в случае ошибки.
*/
size_t tomlSizeEnc(
	char* toml,				/*< [out] код */
	size_t val				/*< [in] значение */
);

/*!	\brief Декодирование неотрицательного целого

	Определяется неотрицательное целое val, закодированное в префиксе
	TOML-кода toml.
	\return Точная длина кода или SIZE_MAX в случае оишбки.
	\remark При декодировании пропускаются предваряющие и завершающие 
	пробелы. Их количество учитывается в возвращаемом значении.
*/
size_t tomlSizeDec(
	size_t* val,			/*< [out] значение */
	const char* toml		/*< [in] код */
);

/*!	\brief Кодирование списка неотрицательных целых

	Определяется число символов в TOML-коде списка неотрицательных целых
	[count]val. Если toml != 0, то TOML-код размещается по этому адресу.
	\pre Если toml != 0, то по адресу toml зарезервировано
	tomlSizesEnc(0, val, count) + 1 символов.
	\return Длина кода или SIZE_MAX в случае ошибки.
*/
size_t tomlSizesEnc(
	char* toml,				/*< [out] код */
	const size_t* val,		/*< [in] список */
	size_t count			/*< [in] длина val */
);

/*!	\brief Декодирование списка неотрицательных целых

	Определяется список неотрицательных целых [count?]val, закодированный
	в префиксе TOML-кода toml.
	\remark Любой из указателей val и count может быть нулевым.
	\pre Буферы, на которые ссылаются ненулевые указатели val и count,
	не пересекаются между собой, но могут пересекаться с буфером toml.
	\return Точная длина кода или SIZE_MAX в случае ошибки.
	\remark При декодировании пропускаются предваряющие и завершающие 
	пробелы. Их количество учитывается в возвращаемом значении.
*/
size_t tomlSizesDec(
	size_t* val,			/*< [out] список */
	size_t* count,			/*< [out] длина val */
	const char* toml		/*< [in] код */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_TOML_H */
