/*
*******************************************************************************
\file hex.h
\brief Hexadecimal strings
\project bee2 [cryptographic library]
\created 2015.10.29
\version 2025.05.06
\copyright The Bee2 authors
\license Licensed under the Apache License, Version 2.0 (see LICENSE.txt).
*******************************************************************************
*/

/*!
*******************************************************************************
\file hex.h
\brief Шестнадцатеричные строки
*******************************************************************************
*/

#ifndef __BEE2_HEX_H
#define __BEE2_HEX_H

#include "bee2/defs.h"
#include "bee2/core/safe.h"
#include "bee2/core/str.h"

#ifdef __cplusplus
extern "C" {
#endif

/*!
*******************************************************************************
\file hex.h

Реализовано управление шестнадцатеричными строками, которые представляют 
буферы памяти. Формально шестнадцатеричный формат задан в RFC 4648 как Base16.

Шестнадцатеричная строка -- это слово в алфавите 
	{'0',..,'9','A',...,'F','a',...,'f'}. 
Символы 'A' и 'a', 'B' и 'b',... считаются эквивалентными. 
В соответствии с RFC 4648 преимущество отдается прописным символам.

\pre Во все функции, кроме возможно hexIsValid(), передаются корректные 
шестнадцатеричные строки и буферы памяти.
*******************************************************************************
*/

/*!	\def hexIsValid
	\brief Корректная шестнадцатеричная строка?

	Проверяется корректность шестнадцатеричной строки hex.
*/
#define hexIsValid(hex)	hexIsValid2(hex, strLen(hex))

/*!	\brief Корректный префикс шестнадцатеричной строки?

	Проверяется корректность префикса [len]hex шестнадцатеричной строки hex. 
	Префикс считается корректным, если он состоит из четного числа символов
	алфавита {'0',..,'9','A',...,'F','a',...,'f'}.
	\return Признак корректности.
	\safe Функция нерегулярна.
*/
bool_t hexIsValid2(
	const char* hex,	/*!< [in] шестнадцатеричная строка */
	size_t len			/*!< [in] длина префикса */
);

/*!	\brief К верхнему регистру

	Строчные символы строки hex преобразуются в прописные.
*/
void hexUpper(
	char* hex			/*!< [in,out] шестнадцатеричная строка */
);

/*!	\brief К нижнему регистру

	Прописные символы строки hex преобразуются в строчные.
*/
void hexLower(
	char* hex			/*!< [in,out] шестнадцатеричная строка */
);

/*!	\def hexEq
	\brief Совпадает с шестнадцатеричной строкой?

	Буфер [strLen(hex) / 2]buf сравнивается с буфером, заданным
	шестнадцатеричной строкой hex.
*/
#define hexEq(buf, hex)	hexEq2(buf, hex, strLen(hex))

/*!	\brief Совпадает с префиксом шестнадцатеричной строки?

	Буфер [len / 2]buf сравнивается с буфером, заданым префиксом [len]hex
	шестнадцатеричной строки hex. Первая пара символов [len]hex
	преобразуется в октет, который сравнивается с первым октетом buf, вторая
	пара сравнивается со вторым октетом buf и т. д.
	\pre hexIsValid2(hex, len) == TRUE.
	\return Признак совпадения.
	\remark Сравнение задается следующим псевдокодом:
	\code
		octet tmp[len / 2];
		hexTo2(tmp, hex, len);
		return memEq(buf, tmp, len/ 2);
	\endcode
	\safe Имеется ускоренная нерегулярная редакция.
*/
bool_t hexEq2(
	const void* buf,	/*!< [in] буфер */
	const char* hex,	/*!< [in] шестнадцатеричная строка */
	size_t len			/*!< [in] длина префикса */
);

bool_t SAFE(hexEq2)(const void* buf, const char* hex, size_t len);
bool_t FAST(hexEq2)(const void* buf, const char* hex, size_t len);

/*!	\def hexEqRev
	\brief Реверсивно совпадает с шестнадцатеричной строкой?

	Буфер [strLen(hex) / 2]buf после разворота октетов сравнивается с буфером,
	заданым шестнадцатеричной строкой hex.
*/
#define hexEqRev(buf, hex)	hexEqRev2(buf, hex, strLen(hex))

/*!	\brief Реверсивно совпадает с префиксом шестнадцатеричной строки?

	Буфер [len / 2]buf сравнивается с буфером, заданым префиксом [len]hex
	шестнадцатеричной строки hex. Первая пара символов [len]hex
	преобразуется в октет, который сравнивается с последним октетом buf,
	вторая пара сравнивается с предпоследним октетом buf и т.д.
	\pre hexIsValid2(hex, len) == TRUE.
	\return Признак совпадения.
	\remark Сравнение задается следующим псевдокодом:
	\code
		octet tmp[len / 2];
		hexTo2(tmp, hex, len);
		memRev(tmp, len / 2);
		return memEq(buf, tmp, len / 2);
	\endcode
	\safe Имеется ускоренная нерегулярная редакция.
*/
bool_t hexEqRev2(
	const void* buf,	/*!< [in] буфер */
	const char* hex,	/*!< [in] шестнадцатеричная строка */
	size_t				/*!< [in] длина префикса */
);

bool_t SAFE(hexEqRev2)(const void* buf, const char* hex, size_t len);
bool_t FAST(hexEqRev2)(const void* buf, const char* hex, size_t len);

/*!	\brief Кодирование шестнадцатеричной строкой

	Буфер [count]src кодируется шестнадцатеричной строкой
	[2 * count + 1]dest. Первому октету src соответствует первая пара 
	символов dest, второму октету -- вторая пара и т.д.
	\pre Буферы dest и src не пересекаются.
*/
void hexFrom(
	char* dest,			/*!< [out] строка-приемник */
	const void* src,	/*!< [in] память-источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Реверсивное кодирование шестнадцатеричной строкой

	Буфер [count]src кодируется шестнадцатеричной строкой 
	[2 * count + 1]dest. Первому октету src соответствует последняя пара 
	символов dest, второму октету -- предпоследняя пара и т.д.
	\pre Буферы dest и src не пересекаются.
*/
void hexFromRev(
	char* dest,			/*!< [out] строка-приемник */
	const void* src,	/*!< [in] память-источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\def hexTo
	\brief Декодирование по шестнадцатеричной строке

	Буфер [strLen(src) / 2]dest декодируется по шестнадцатеричной строке src.
*/
#define hexTo(dest, src) hexTo2(dest, src, strLen(src))

/*!	\brief Декодирование по префиксу шестнадцатеричной строки

	Префикс [len]src шестнадцатеричной строки src преобразуется в буфер
	[len / 2]dest. По первой паре символов src определяется первый октет
	dest, по второй паре -- второй октет и т.д.
	\pre hexIsValid2(hex, len) == TRUE.
*/
void hexTo2(
	void* dest,			/*!< [out] память-приемник */
	const char* src,	/*!< [in] строка-источник */
	size_t len			/*!< [in] длина префикса */
);

/*!	\def hexToRev
	\brief Реверсивное декодирование по шестнадцатеричной строке

	Буфер [strLen(src) / 2]dest декодируется с разворотом откетов по
	шестнадцатеричной строке src. 
*/
#define hexToRev(dest, src) hexToRev2(dest, src, strLen(src))

/*!	\brief Реверсивное декодирование по префиксу шестнадцатеричной строки

	Префикс [len]src шестнадцатеричной строки src преобразуется в буфер
	[len / 2]dest. По последней паре символов src определяется первый 
	октет dest, по предпоследней паре -- второй октет и т. д.
	\pre hexIsValid2(hex, len) == TRUE.
*/
void hexToRev2(
	void* dest,			/*!< [out] память-приемник */
	const char* src,	/*!< [in] строка-источник */
	size_t len			/*!< [in] длина префикса */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __BEE2_HEX_H */
